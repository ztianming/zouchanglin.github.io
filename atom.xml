<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tim&#39;s Blog</title>
  
  <subtitle>当你凝望深渊时，深渊也在凝望你</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zouchanglin.cn/"/>
  <updated>2020-02-25T11:34:19.377Z</updated>
  <id>https://zouchanglin.cn/</id>
  
  <author>
    <name>changlin zou</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HTTPS协议实现原理</title>
    <link href="https://zouchanglin.cn/2020/02/25/HTTPS%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://zouchanglin.cn/2020/02/25/HTTPS%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2020-02-25T11:01:35.000Z</published>
    <updated>2020-02-25T11:34:19.377Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200225/meVCCACO399R.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;HTTP协议的信息传输完全以明文方式，不做任何加密，相当于是在网络上”裸奔”。意思就是如果我们以HTTP来传输数据的话由于是明文数据，则很容易发生不安全事故，比如我登陆一个网站，那么如果是HTTP明文传输肯定就会直接把用户名和密码放在明文中，这样是非常不安全的，处在同一个局域网下的小伙伴直接抓包就可以获取你的用户名和密码，那么应该怎么办呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://zouchanglin.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://zouchanglin.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="网络安全" scheme="https://zouchanglin.cn/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
      <category term="非对称加密" scheme="https://zouchanglin.cn/tags/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>TCP的高性能机制</title>
    <link href="https://zouchanglin.cn/2020/02/25/TCP%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%9C%BA%E5%88%B6/"/>
    <id>https://zouchanglin.cn/2020/02/25/TCP%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%9C%BA%E5%88%B6/</id>
    <published>2020-02-25T04:01:35.000Z</published>
    <updated>2020-02-25T08:18:01.949Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200225/WFp4qQSRpvoo.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;之前介绍了TCP的报文格式（&lt;a href=&quot;https://zouchanglin.cn/2019/11/21/TCP协议基本特性&quot;&gt;《TCP协议基本特性》&lt;/a&gt;），TCP的连接管理，学习了TCP如何建立连接，释放连接以及一些网络安装方面的问题，现在还剩下TCP的几个关键机制，主要是TPC的延迟应答和捎带应答、超时重传、快重传和快恢复、滑动窗口机制、拥塞避免算法；然后最后还记录了TCP的粘包问题和解决方案！&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://zouchanglin.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://zouchanglin.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>谈谈HTTP协议</title>
    <link href="https://zouchanglin.cn/2020/02/25/%E8%B0%88%E8%B0%88HTTP%E5%8D%8F%E8%AE%AE/"/>
    <id>https://zouchanglin.cn/2020/02/25/%E8%B0%88%E8%B0%88HTTP%E5%8D%8F%E8%AE%AE/</id>
    <published>2020-02-25T04:01:35.000Z</published>
    <updated>2020-02-25T11:34:29.669Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;HTTP的全称 HyperText Transfer Protocol，即超文本传输协议，程序员自己发明的协议之一，基于TCP的应用层协议。 HTTP协议是基于请求-响应的模式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200225/k8pW0raF9ync.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;HTTP是一种无状态协议，HTTP协议自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个级别，协议对于发送过的请求或响应都不做持久化处理。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200225/GqrhjlASQXoQ.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://zouchanglin.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://zouchanglin.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>构造实现简单容器</title>
    <link href="https://zouchanglin.cn/2020/02/24/%E6%9E%84%E9%80%A0%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E5%AE%B9%E5%99%A8/"/>
    <id>https://zouchanglin.cn/2020/02/24/%E6%9E%84%E9%80%A0%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E5%AE%B9%E5%99%A8/</id>
    <published>2020-02-24T14:38:52.806Z</published>
    <updated>2020-02-24T15:10:43.606Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;现在即将开始真正踏上构造自己的容器的道路。我们会基于当前的操作系统创建一个与宿主机隔离的容器环境，下面就开始吧。在开始之前我们需要先对Linux的proc文件系统做一个介绍：&lt;/p&gt;
&lt;p&gt;如果你对这些基本知识已经很熟悉了，请直接略过。Linux下的/proc文件系统是由内核提供的，它其实不是一个真正的文件系统，只包含了系统运行时的信息（比如系统内存、mount设备信息、一些硬件配置等），它只存在于内存中，而不占用外存空间。它以文件系统的形式，为访问内核数据的操作提供接口。实际上，很多系统工具都是简单地去读取这个文件系统的某个文件内容，比如lsmod，其实就是cat /proc/modules。当遍历这个目录的时候，会发现很多数字，这些都是为每个进程创建的空间，数字就是它们的PID。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200224/sVzVSYCvKI6y.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="虚拟化技术" scheme="https://zouchanglin.cn/categories/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Docker" scheme="https://zouchanglin.cn/tags/Docker/"/>
    
      <category term="Linux" scheme="https://zouchanglin.cn/tags/Linux/"/>
    
      <category term="Golang" scheme="https://zouchanglin.cn/tags/Golang/"/>
    
      <category term="文件系统" scheme="https://zouchanglin.cn/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>动手实现AUFS文件系统</title>
    <link href="https://zouchanglin.cn/2020/02/23/%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0AUFS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>https://zouchanglin.cn/2020/02/23/%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0AUFS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-02-23T03:37:40.000Z</published>
    <updated>2020-02-23T04:39:19.043Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200223/8sHdcObI1bOG.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;在之前的文章中我们探究了Docker是如何使用AUFS文件系统的，现在我们开始动手实践一下AUFS，用简单的命令来创建一个AUFS文件系统，感受下如何使用AUFS和COW实现文件管理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="虚拟化技术" scheme="https://zouchanglin.cn/categories/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Docker" scheme="https://zouchanglin.cn/tags/Docker/"/>
    
      <category term="Linux" scheme="https://zouchanglin.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Union File System在Docker中的应用</title>
    <link href="https://zouchanglin.cn/2020/02/22/Union%20File%20System%E5%9C%A8Docker%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>https://zouchanglin.cn/2020/02/22/Union%20File%20System%E5%9C%A8Docker%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</id>
    <published>2020-02-22T07:15:41.000Z</published>
    <updated>2020-02-23T03:38:38.028Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Union-File-System&quot;&gt;&lt;a href=&quot;#Union-File-System&quot; class=&quot;headerlink&quot; title=&quot;Union File System&quot;&gt;&lt;/a&gt;Union File System&lt;/h2&gt;&lt;p&gt;Union File System，简称UnionFS，关于联合文件系统我之前的一篇博客里也写过的&lt;a href=&quot;https://zouchanglin.cn/2019/08/03/Docker镜像与数据容器卷&quot;&gt;《Docker镜像与数据容器卷》&lt;/a&gt;，是一种为Linux、FreeBSD 和NetBSD操作系统设计的，把其他文件系统联合到一个联合挂载点的文件系统服务。它使用branch把不同文件系统的文件和目录“透明地”覆盖，形成一个单一一致的文件系统。这些branch或者是read-only的，或者是read-write的，所以当对这个虚拟后的联合文件系统进行写操作的时候，系统是真正写到了一个新的文件中。看起来这个虚拟后的联合文件系统是可以对任何文件进行操作的，但是其实它并没有改变原来的文件,这是因为unionfs用到了一个重要的资源管理技术，叫写时拷贝。&lt;/p&gt;
    
    </summary>
    
    
      <category term="虚拟化技术" scheme="https://zouchanglin.cn/categories/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Docker" scheme="https://zouchanglin.cn/tags/Docker/"/>
    
      <category term="Linux" scheme="https://zouchanglin.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Cgroups在Docker中的应用</title>
    <link href="https://zouchanglin.cn/2020/02/22/Cgroups%E5%9C%A8Docker%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>https://zouchanglin.cn/2020/02/22/Cgroups%E5%9C%A8Docker%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</id>
    <published>2020-02-22T04:20:19.000Z</published>
    <updated>2020-02-23T02:12:12.191Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;之前几篇文章讲述了Linux的Cgroups技术，&lt;a href=&quot;https://zouchanglin.cn/2020/02/20/Linux-Cgroups的资源控制/&quot;&gt;《Linux-Cgroups的资源控制》&lt;/a&gt;，主要是通过Cgroups实现了对进程的资源限制，那么在Docker中是如何运用Cgroups的呢？我们知道Docker是通过Cgroups去做的容器的资源限制和监控，我们下面就以一个实际的容器实例来看下Docker是如何配置Cgroups的：&lt;code&gt;docker run -m 设置内存限制&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200222/U7v1jf2JBKla.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以看到Docker通过为每个容器创建Cgroup并通过Cgroup去配置的资源限制和资源监控。&lt;/strong&gt; &lt;/p&gt;
    
    </summary>
    
    
      <category term="虚拟化技术" scheme="https://zouchanglin.cn/categories/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Docker" scheme="https://zouchanglin.cn/tags/Docker/"/>
    
      <category term="Linux" scheme="https://zouchanglin.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Apache Freemarker的一个小坑</title>
    <link href="https://zouchanglin.cn/2020/02/21/Apache-Freemarker%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9D%91/"/>
    <id>https://zouchanglin.cn/2020/02/21/Apache-Freemarker%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9D%91/</id>
    <published>2020-02-21T03:38:53.000Z</published>
    <updated>2020-02-21T03:46:41.608Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn/FjkyX6iIHmYl6IFqrwnlZUnLBFXd&quot; alt=&quot;xxx.png&quot;&gt;&lt;br&gt;前段时间用到了Apache Freemarker来做前端页面，发现一个问题，就是JavaBean的Long类型和Integer类型向模板中注入的时候，只要是注入input类型，那么大&lt;br&gt;于999的数字则不会被显示，这个问题我也问了Apache官方的论坛：&lt;a href=&quot;https://issues.apache.org/jira/browse/FREEMARKER-132&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://issues.apache.org/jira/browse/FREEMARKER-132&lt;/a&gt; ,果然是官方站点呀，反馈还是很快的，系统还自动发了邮件！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web开发" scheme="https://zouchanglin.cn/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaWeb" scheme="https://zouchanglin.cn/tags/JavaWeb/"/>
    
      <category term="模板引擎" scheme="https://zouchanglin.cn/tags/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"/>
    
      <category term="前端" scheme="https://zouchanglin.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Linux Cgroups的资源控制</title>
    <link href="https://zouchanglin.cn/2020/02/20/Linux-Cgroups%E7%9A%84%E8%B5%84%E6%BA%90%E6%8E%A7%E5%88%B6/"/>
    <id>https://zouchanglin.cn/2020/02/20/Linux-Cgroups%E7%9A%84%E8%B5%84%E6%BA%90%E6%8E%A7%E5%88%B6/</id>
    <published>2020-02-20T12:03:27.000Z</published>
    <updated>2020-02-22T04:16:12.053Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;今天主要是说说Linux的Cgroup技术，之前介绍的是构建Linux容器的namespace技术，它能够很好的帮助进程隔离出自己单独的空间，但Docker又是怎么限制每个空间的大小，保证他们不会互相争抢呢？这就要用到Linux的Cgroups技术。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200221/EHaOfXGVfWwE.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;Linux Cgroups(Control Groups) 提供了对一组进程及将来的子进程的资源的限制 ，控制和统计的能力，这些资源包括CPU，内存，存储，网络等。通过Cgroups，可以方便的限制某个进程的资源占用，并且可以实时的监控进程的监控和统计信息。&lt;/p&gt;
    
    </summary>
    
    
      <category term="虚拟化技术" scheme="https://zouchanglin.cn/categories/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Docker" scheme="https://zouchanglin.cn/tags/Docker/"/>
    
      <category term="Linux" scheme="https://zouchanglin.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>通过Namespace实现隔离</title>
    <link href="https://zouchanglin.cn/2020/02/19/%E9%80%9A%E8%BF%87Namespace%E5%AE%9E%E7%8E%B0%E9%9A%94%E7%A6%BB/"/>
    <id>https://zouchanglin.cn/2020/02/19/%E9%80%9A%E8%BF%87Namespace%E5%AE%9E%E7%8E%B0%E9%9A%94%E7%A6%BB/</id>
    <published>2020-02-19T07:02:22.000Z</published>
    <updated>2020-02-20T06:54:10.387Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200219/96tchOUQRfiQ.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;在上次的文章&lt;a href=&quot;[https://zouchanglin.cn/2020/02/18/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%9F%BA%E7%9F%B3%E2%80%94%E2%80%94Namespace/](https://zouchanglin.cn/2020/02/18/虚拟化的基石——Namespace/)&quot;&gt;《虚拟化的基石——Namespace》&lt;/a&gt; 中主要讲述了Namespace的作用，却没有详细的拿代码举证，上次仅仅证明了UTS Namespace，剩下五个命名空间全在这篇文章了，主要是IPC Namespace、PID Namespace、Mount Namespace、User Namespace、Network Namespace的概念的理解以及使用代码证明！&lt;/p&gt;
    
    </summary>
    
    
      <category term="虚拟化技术" scheme="https://zouchanglin.cn/categories/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Docker" scheme="https://zouchanglin.cn/tags/Docker/"/>
    
      <category term="Linux" scheme="https://zouchanglin.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>虚拟化的基石——Namespace</title>
    <link href="https://zouchanglin.cn/2020/02/18/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%9F%BA%E7%9F%B3%E2%80%94%E2%80%94Namespace/"/>
    <id>https://zouchanglin.cn/2020/02/18/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%9F%BA%E7%9F%B3%E2%80%94%E2%80%94Namespace/</id>
    <published>2020-02-18T14:44:21.000Z</published>
    <updated>2020-02-20T06:54:14.123Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;每每被人问到：“Docker技术到底是怎么实现的呢？”我只能粗粗浅浅地说：“Docker是使用Linux Kernel的Namespace 和 Cgroups实现的一种容器技术。”那么，什么是Namespace，什么是Cgroups，Docker是怎么使用它们的，容器到底是怎么一步步被创建出来的？问到这些，我就会支支吾吾地不知所以。由此可见，了解容器技术的底层技术，然后明白它们是如何工作的，尤为重要，这些才是整个容器技术的基石，掌握了这些基石才能更加容易地向上攀登。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那今天就先看看Namespace吧！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200218/07pgJ5CxHbna.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="虚拟化技术" scheme="https://zouchanglin.cn/categories/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Docker" scheme="https://zouchanglin.cn/tags/Docker/"/>
    
      <category term="Linux" scheme="https://zouchanglin.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>构建可复用模块</title>
    <link href="https://zouchanglin.cn/2020/02/18/%E6%9E%84%E5%BB%BA%E5%8F%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E6%A8%A1%E5%9D%97/"/>
    <id>https://zouchanglin.cn/2020/02/18/%E6%9E%84%E5%BB%BA%E5%8F%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E6%A8%A1%E5%9D%97/</id>
    <published>2020-02-18T02:27:22.000Z</published>
    <updated>2020-02-20T06:53:57.117Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Golang的工程管理一直是初学者所不能很好的理解的事物，本篇主要讲述了在Golang中如何进行工程管理，如何构建可复用模块，从GitHub获取Go的包是如何操作的，以及Golang的包管理工具的基本使用，这样再进行项目开发的时候就可以模块化的管理自己的工程，首先还得从Package说起！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200218/9Uui7Swk4Vcp.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="工程构建" scheme="https://zouchanglin.cn/categories/%E5%B7%A5%E7%A8%8B%E6%9E%84%E5%BB%BA/"/>
    
    
      <category term="Golang" scheme="https://zouchanglin.cn/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>在Golang中处理异常</title>
    <link href="https://zouchanglin.cn/2020/02/17/%E5%9C%A8Golang%E4%B8%AD%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8/"/>
    <id>https://zouchanglin.cn/2020/02/17/%E5%9C%A8Golang%E4%B8%AD%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8/</id>
    <published>2020-02-17T12:04:22.000Z</published>
    <updated>2020-02-20T06:54:25.469Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;通常我们需要编写好的错误处理方式，在了避免某些程序员滥用异常，于是Go这里直接把异常这一块给砍掉了，最终还是通过返回值来判断程序的异常情况，毕竟Go可是支持多返回值的语言，比如atoi、itoa等函数，就不能忽略它的第二个返回值，因为第二个返回值代表了转换是否成功！不过Golang还是提供了一些错误处理机制的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200217/IvGCHwjRpvVi.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="https://zouchanglin.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Golang" scheme="https://zouchanglin.cn/tags/Golang/"/>
    
      <category term="异常处理" scheme="https://zouchanglin.cn/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>实践Go的面向对象</title>
    <link href="https://zouchanglin.cn/2020/02/17/%E5%AE%9E%E8%B7%B5Go%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>https://zouchanglin.cn/2020/02/17/%E5%AE%9E%E8%B7%B5Go%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</id>
    <published>2020-02-17T09:22:21.000Z</published>
    <updated>2020-02-20T06:54:06.178Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Go是一种面向对象的语言吗？ &lt;/p&gt;
&lt;p&gt;关于Go是一种面向对象的语言吗这种问题，官方的解释是难说，说不准，这回答就有意思了！在我看来尽管Go具有类型和方法，并允许使用面向对象的编程风格，但没有类型层次结构。 Go的接口完全提供了一种不同的方法，可以将类型嵌入其他类型，达到继承的效果，其实又完全不同于继承，因为Go其中一个特点是可以为任何类型的数据定义方法，所以再讨论Go是不是面向对象的语言的时候还是可以先体验体验Go的Functional Programming&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200217/KzljGvryaBkw.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="https://zouchanglin.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Golang" scheme="https://zouchanglin.cn/tags/Golang/"/>
    
      <category term="面向对象" scheme="https://zouchanglin.cn/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Golang值得注意的点</title>
    <link href="https://zouchanglin.cn/2020/02/16/Golang%E5%80%BC%E5%BE%97%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9/"/>
    <id>https://zouchanglin.cn/2020/02/16/Golang%E5%80%BC%E5%BE%97%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9/</id>
    <published>2020-02-16T08:52:02.000Z</published>
    <updated>2020-02-20T06:57:11.374Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;记录了一下最近学习golang语言遗忘的和模糊的知识点，主要涵盖主函数退出返回值、如何编写测试程序、如何定义常量、golang的类型转换、golang中的预定义值、指针与其他语言的差异（主要是C语言），以及运算符等等！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200216/SHPRYlCdVQO1.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="https://zouchanglin.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Golang" scheme="https://zouchanglin.cn/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang的常用容器</title>
    <link href="https://zouchanglin.cn/2020/02/16/Golang%E7%9A%84%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/"/>
    <id>https://zouchanglin.cn/2020/02/16/Golang%E7%9A%84%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/</id>
    <published>2020-02-15T16:00:00.000Z</published>
    <updated>2020-02-20T06:53:10.653Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;本篇主要是讲述了数组和切片、Map的初始化方式与基本使用、重点阐述了如何使用Map实现Set、用Map实现工厂模式，以及字符串的使用，字符串常用API、Unicode与UTF8的关系！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200216/cdGfnUuRhwPr.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="https://zouchanglin.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Golang" scheme="https://zouchanglin.cn/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>IDEA插件推荐</title>
    <link href="https://zouchanglin.cn/2020/02/15/IDEA%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
    <id>https://zouchanglin.cn/2020/02/15/IDEA%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/</id>
    <published>2020-02-14T16:00:00.000Z</published>
    <updated>2020-02-20T06:53:28.240Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200216/igy99NdTRXcF.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Alibaba-Java-Coding-Guidelines&quot;&gt;&lt;a href=&quot;#Alibaba-Java-Coding-Guidelines&quot; class=&quot;headerlink&quot; title=&quot;Alibaba Java Coding Guidelines&quot;&gt;&lt;/a&gt;Alibaba Java Coding Guidelines&lt;/h2&gt;&lt;p&gt;写代码怎么能没有规范呢？这款插件是伴随阿里巴巴编码约规出现的，自我感觉是必须要安装的插件&lt;/p&gt;
&lt;h2 id=&quot;Lombok&quot;&gt;&lt;a href=&quot;#Lombok&quot; class=&quot;headerlink&quot; title=&quot;Lombok&quot;&gt;&lt;/a&gt;Lombok&lt;/h2&gt;&lt;p&gt;以前的Java项目中，充斥着太多不友好的代码：各种getter/setter/toString；异常处理；I/O流的关闭操作等等，这些样板代码既没有技术含量，又影响着代码的美观，Lombok必备！不要忘记引入Lombok依赖&lt;/p&gt;
    
    </summary>
    
    
      <category term="开发工具" scheme="https://zouchanglin.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="IDEA" scheme="https://zouchanglin.cn/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>NIO网络通信</title>
    <link href="https://zouchanglin.cn/2020/02/09/NIO%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
    <id>https://zouchanglin.cn/2020/02/09/NIO%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/</id>
    <published>2020-02-08T23:52:02.000Z</published>
    <updated>2020-02-20T06:53:32.579Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;阻塞式IO与非阻塞式IO&quot;&gt;&lt;a href=&quot;#阻塞式IO与非阻塞式IO&quot; class=&quot;headerlink&quot; title=&quot;阻塞式IO与非阻塞式IO&quot;&gt;&lt;/a&gt;阻塞式IO与非阻塞式IO&lt;/h2&gt;&lt;p&gt;传统的IO流都是阻塞式的。也就是说，当一个线程调用read() 或write()时，该线程被阻塞，直到有一些数据被读取或写入，该线程在此期间不能执行其他任务。因此，在完成网络通信进行IO操作时，由于线程会阻塞，所以服务器端必须为每个客户端都提供一个独立的线程进行处理，当服务器端需要处理大量客户端时，性能急剧下降。&lt;/p&gt;
&lt;p&gt;Java NIO是非阻塞模式的。当线程从某通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。线程通常将非阻塞IO的空闲时间用于在其他通道上执行I0操作，所以单独的线程可以管理多个输入和输出通道。因此，NIO可以让服务器端使用一个或有限几个线程来同时处理连接到服务器端的所有客户端。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200209/KXe8DDICWRg6.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="高性能网络" scheme="https://zouchanglin.cn/categories/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="NIO" scheme="https://zouchanglin.cn/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>NIO与通道数据传输</title>
    <link href="https://zouchanglin.cn/2020/02/08/NIO%E4%B8%8E%E9%80%9A%E9%81%93%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/"/>
    <id>https://zouchanglin.cn/2020/02/08/NIO%E4%B8%8E%E9%80%9A%E9%81%93%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/</id>
    <published>2020-02-08T11:24:22.000Z</published>
    <updated>2020-02-20T06:53:43.779Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;NIO的通道&quot;&gt;&lt;a href=&quot;#NIO的通道&quot; class=&quot;headerlink&quot; title=&quot;NIO的通道&quot;&gt;&lt;/a&gt;NIO的通道&lt;/h2&gt;&lt;p&gt;通道( Channel) ：由java.nio.channels包定义的。Channel 表示IO源与目标打开的连接。Channel类似于传统的“流”， 只不过Channel本身不能直接访问数据，Channel只能与Buffer进行交互。&lt;/p&gt;
&lt;p&gt;应用程序与磁盘之间的数据写入或者读出，都需要由用户地址空间和内存地址空间之间来回复制数据，内存地址空间中的数据通过操作系统层面的IO接口，完成与磁盘的数据存取。在应用程序调用这些系统IO接口时，由CPU完成一系列调度、任务分配，在早期这些IO接口都是由CPU独立负责。所以当发生大规模读写请求时，CPU的占用率很高。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200208/ERDg8DebUJIv.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="高性能网络" scheme="https://zouchanglin.cn/categories/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
      <category term="JVM" scheme="https://zouchanglin.cn/tags/JVM/"/>
    
      <category term="NIO" scheme="https://zouchanglin.cn/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>NIO与缓冲区</title>
    <link href="https://zouchanglin.cn/2020/02/08/NIO%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA/"/>
    <id>https://zouchanglin.cn/2020/02/08/NIO%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA/</id>
    <published>2020-02-08T05:54:00.000Z</published>
    <updated>2020-02-20T06:53:37.308Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200208/grYNG4qQBUjR.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Java-NIO简介&quot;&gt;&lt;a href=&quot;#Java-NIO简介&quot; class=&quot;headerlink&quot; title=&quot;Java NIO简介&quot;&gt;&lt;/a&gt;Java NIO简介&lt;/h2&gt;&lt;p&gt;Java NIO (New IO/Non Blocking IO)，官方给的定义是New IO，但是我们也可以当作是Non Blocking IO，即非阻塞式IO，是从Java 1.4版本开始引入的一个新的IO API，可以替代标准的Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支 持面向缓冲区的、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="高性能网络" scheme="https://zouchanglin.cn/categories/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
      <category term="JVM" scheme="https://zouchanglin.cn/tags/JVM/"/>
    
      <category term="NIO" scheme="https://zouchanglin.cn/tags/NIO/"/>
    
  </entry>
  
</feed>
