<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tim&#39;s Blog</title>
  
  <subtitle>加油，冲冲冲...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zouchanglin.cn/"/>
  <updated>2020-04-17T04:07:16.105Z</updated>
  <id>https://zouchanglin.cn/</id>
  
  <author>
    <name>邹长林</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JDK8新特性</title>
    <link href="https://zouchanglin.cn/2020/04/14/JDK8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://zouchanglin.cn/2020/04/14/JDK8%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2020-04-14T10:00:00.000Z</published>
    <updated>2020-04-17T04:07:16.105Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;虽然已经用过了一些Java8的新特性，但是总来没有仔细总结一下。Java8自从2014年就发布了，到目前为止只有一小部分公司在用JDK7及其以下的版本，大部分已经迁移至Java8，甚至Java11（关于Java9和Java11的特性我会在之后两篇文章中记述），目前只看Java8那些最主要的、也是最常用的新特性，我到目前为止用到的最多的也就是Stream API和Lambda表达式，新时间日期的API也比较常用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="https://zouchanglin.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
      <category term="Stream" scheme="https://zouchanglin.cn/tags/Stream/"/>
    
      <category term="Lambda" scheme="https://zouchanglin.cn/tags/Lambda/"/>
    
  </entry>
  
  <entry>
    <title>堆的实现及其应用</title>
    <link href="https://zouchanglin.cn/2020/04/13/%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"/>
    <id>https://zouchanglin.cn/2020/04/13/%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</id>
    <published>2020-04-13T10:00:00.000Z</published>
    <updated>2020-04-15T14:23:19.934Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章记述的是堆排序，这个名字看起来好像又要介绍一个排序算法，但是排序算法是次要的，主要的是一个数据结构——堆。堆排序问题就是堆这种数据结构所衍生出来的一个应用，我们先了解一下优先队列的概念。普通的队列就是满足先进先出、后进后出的一个结构。那么优先级队列呢？出队顺序和入队顺序无关，和优先级相关，这就比如在医院看病，肯定是急诊病人优先看病。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://zouchanglin.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="https://zouchanglin.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
      <category term="堆" scheme="https://zouchanglin.cn/tags/%E5%A0%86/"/>
    
      <category term="二叉树" scheme="https://zouchanglin.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>注解的原理与实现</title>
    <link href="https://zouchanglin.cn/2020/04/12/%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>https://zouchanglin.cn/2020/04/12/%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-04-12T10:00:00.000Z</published>
    <updated>2020-04-15T06:04:25.034Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;注解这个东西自从SpringBoot以来一直是Java开发者们必备的生存技巧呀，我们平时几乎大部分时间都是面向注解编程，通过注解我们可以节约大量的时间。用过了这么多的注解，那么我们否有关注过注解的实现原理呢？所以本篇文章主要是讲述注解的有关操作，自己实现一个注解来体会注解的实现原理，注解也不是特别高深的东西，掌握了自然就明白了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="https://zouchanglin.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="JavaWeb" scheme="https://zouchanglin.cn/tags/JavaWeb/"/>
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
      <category term="JavaEE" scheme="https://zouchanglin.cn/tags/JavaEE/"/>
    
  </entry>
  
  <entry>
    <title>关于快排和归并的思考</title>
    <link href="https://zouchanglin.cn/2020/04/11/%E5%85%B3%E4%BA%8E%E5%BF%AB%E6%8E%92%E5%92%8C%E5%BD%92%E5%B9%B6%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>https://zouchanglin.cn/2020/04/11/%E5%85%B3%E4%BA%8E%E5%BF%AB%E6%8E%92%E5%92%8C%E5%BD%92%E5%B9%B6%E7%9A%84%E6%80%9D%E8%80%83/</id>
    <published>2020-04-11T10:00:00.000Z</published>
    <updated>2020-04-14T12:01:02.853Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;归并排序和快速排序是两种稍微复杂的排序算法，它们用的都是分治的思想，代码都通过递归来实现，过程非常相似。归并排序算法是一种在任何情况下时间复杂度都比较稳定的排序算法，这也使它存在致命的缺点，即归并排序不是原地排序算法，空间复杂度比较高，是 O(n)。正因为此它也没有快排应用广泛。快速排序算法虽然最坏情况下的时间复杂度是 O(n²)，但是平均情况下时间复杂度都是 O(nlogn)。且快速排序算法时间复杂度退化到 O(n²) 的概率非常小，我们可以通过合理地选择基准值来避免这种情况。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://zouchanglin.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="https://zouchanglin.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>快速排序及其优化</title>
    <link href="https://zouchanglin.cn/2020/04/10/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"/>
    <id>https://zouchanglin.cn/2020/04/10/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/</id>
    <published>2020-04-10T10:00:00.000Z</published>
    <updated>2020-04-14T10:06:23.620Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;快速排序(Quick Sort)被称为20世纪对世界影响最大的算法之一，现在我们来看快速排序算法，习惯性把它简称为快排，快排利用的也是分治思想。乍看起来，它有点像归并排序，但是思路其实完全不一样。现在，我们先来看下快排的核心思想，最后将讲述快速排序的两个优化方案，其实还有一种三路快排的优化方案也是可以的，但是本片文章重点在于快速排序的原理和实现，所以三路快排的优化方案不会出现在这篇文章里，以后再详细记录一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://zouchanglin.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="https://zouchanglin.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>O(nLogn)的归并排序</title>
    <link href="https://zouchanglin.cn/2020/04/09/O(nLogn)%E7%9A%84%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>https://zouchanglin.cn/2020/04/09/O(nLogn)%E7%9A%84%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</id>
    <published>2020-04-09T10:00:00.000Z</published>
    <updated>2020-04-12T01:13:31.777Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;之前几篇文章我介绍了三种O(n²)的排序算法&lt;a href=&quot;https://zouchanglin.cn/2020/04/07/O(n²)的三个排序算法&quot;&gt;《O(n²)的三个排序算法》&lt;/a&gt;（选择排序、插入排序和冒泡排序）以及它们的优化，然后顺便还写了一篇希尔排序的文章&lt;a href=&quot;https://zouchanglin.cn/2020/04/09/插入排序的优化之希尔排序&quot;&gt;《插入排序的优化之希尔排序》&lt;/a&gt;，但是其实用的比较多的还是直接插入排序，它们比较适合于小规模数据的排序 。下面我将记录时间复杂度为nlog(n)的几种排序算法之一 —— 归并排序算法，这种排序算法适合大规模的数据排序，比之前的O(n²)的三种排序算法更为常用，在学习之前我们可以先对比一下nlog(n)和n²是什么概念。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://zouchanglin.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="https://zouchanglin.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>插入排序的优化之希尔排序</title>
    <link href="https://zouchanglin.cn/2020/04/09/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BC%98%E5%8C%96%E4%B9%8B%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    <id>https://zouchanglin.cn/2020/04/09/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BC%98%E5%8C%96%E4%B9%8B%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</id>
    <published>2020-04-09T03:00:00.000Z</published>
    <updated>2020-04-09T04:42:28.387Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;希尔排序是插入排序的一种，又称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法，可以说它是插入排序的高级版。我们可以先回顾一下直接插入排序的过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200408/epYKaCrsQqxV.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;排序前将第一个元素看成有序的数列&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第1趟排序后：得到一个长度为2的有序数列&lt;/li&gt;
&lt;li&gt;第2趟排序后：得到一个长度为3的有序数列&lt;/li&gt;
&lt;li&gt;第3趟排序后：得到一个长度为4的有序数列&lt;/li&gt;
&lt;li&gt;……..每趟插入排序，都可以将一个无序值插入一个有序数列，直到全部元素有序&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://zouchanglin.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="https://zouchanglin.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>O(n²)的三个排序算法</title>
    <link href="https://zouchanglin.cn/2020/04/07/O(n%C2%B2)%E7%9A%84%E4%B8%89%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://zouchanglin.cn/2020/04/07/O(n%C2%B2)%E7%9A%84%E4%B8%89%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2020-04-07T10:00:00.000Z</published>
    <updated>2020-04-10T01:41:15.470Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;今天复习下最简单的三个排序算法，一个是选择排序，一个是插入排序，一个是冒泡排序，三者时间复杂度都是O(n²)，通过分析来发现三者的优劣，以及对最好的情况和最坏的情况进行分析。 另外，这三中排序算法都是基于比较的排序算法。基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。所以，如果我们在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://zouchanglin.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="https://zouchanglin.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>SpringIOC原理与应用</title>
    <link href="https://zouchanglin.cn/2020/04/05/SpringIOC%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <id>https://zouchanglin.cn/2020/04/05/SpringIOC%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/</id>
    <published>2020-04-05T10:00:00.000Z</published>
    <updated>2020-04-14T03:02:16.327Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200405/HbNPDVawlHpU.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;ICO容器的结构如上图所示，首先要让IOC容器去读取Bean的配置信息，并在容器中生成一份相应的Bean定义注册表，根据这张注册表去实例化Bean，装配好Bean之间的依赖关系，为上层提供准备就绪的环境，Spring提供一个配置文件描述Bean还有Bean之间的依赖关系，利用Java语言的反射功能实例化Bean并建立Bean之间的依赖关系。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web开发" scheme="https://zouchanglin.cn/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaEE" scheme="https://zouchanglin.cn/tags/JavaEE/"/>
    
      <category term="SpringCore" scheme="https://zouchanglin.cn/tags/SpringCore/"/>
    
  </entry>
  
  <entry>
    <title>如何理解SpringIOC</title>
    <link href="https://zouchanglin.cn/2020/04/05/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3SpringIOC/"/>
    <id>https://zouchanglin.cn/2020/04/05/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3SpringIOC/</id>
    <published>2020-04-05T06:00:00.000Z</published>
    <updated>2020-04-14T03:02:25.225Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200405/IHCyMIrsdTrx.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;SpringIOC是Spring Core最核心的部分，要了解控制反转(Inversion of Control)，我觉得有必要先了解软件设计的一个重要思想：依赖倒置原则。 &lt;/p&gt;
&lt;p&gt;1、高层模块不应该依赖底层模块，二者都应该依赖抽象&lt;br&gt;2、抽象不应该依赖细节，细节应该依赖抽象。&lt;br&gt;3、依赖倒置的中心思想是面向接口编程。&lt;br&gt;4、依赖倒置原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础搭建的架构要稳定的多。&lt;br&gt;5、使用接口或抽象类的目的是指定好规范，而不涉及任何具体操作，展现细节的任务交给他们的实现类来完成。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web开发" scheme="https://zouchanglin.cn/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaEE" scheme="https://zouchanglin.cn/tags/JavaEE/"/>
    
      <category term="SpringCore" scheme="https://zouchanglin.cn/tags/SpringCore/"/>
    
  </entry>
  
  <entry>
    <title>JUC的四个并发工具类</title>
    <link href="https://zouchanglin.cn/2020/04/05/JUC%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>https://zouchanglin.cn/2020/04/05/JUC%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/</id>
    <published>2020-04-05T04:00:00.000Z</published>
    <updated>2020-04-14T03:05:32.002Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章主要记录了JUC的四个并发工具类，闭锁CountDownlatch、栅栏CyclicBarrier、信号量Semaphore、交换器Exchanger。CountDownlatch通常用于主线程等待其他任务线程执行完毕的场景；CyclicBarrier主要阻塞当前线程，等待其他线程（大家无论谁先跑到A点，必须要等其他线程也到达了A点，大家才能继续）。信号量Semaphore可以用来控制同时访问特定资源的线程数量（比如100个线程只能有10个线程可以获得MySQL连接）。交换器Exchanger很少用，只适用于两个线程在同步点交换数据的场景（如下图）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200404/xTzG4uGsytB7.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="并发编程" scheme="https://zouchanglin.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="异步" scheme="https://zouchanglin.cn/tags/%E5%BC%82%E6%AD%A5/"/>
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
      <category term="JUC" scheme="https://zouchanglin.cn/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>ForkJoin框架与读写锁</title>
    <link href="https://zouchanglin.cn/2020/04/04/ForkJoin%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%BB%E5%86%99%E9%94%81/"/>
    <id>https://zouchanglin.cn/2020/04/04/ForkJoin%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%BB%E5%86%99%E9%94%81/</id>
    <published>2020-04-04T04:00:00.000Z</published>
    <updated>2020-04-14T03:05:45.788Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Fork/Join框架就是在必要的情况下，将一个大任务，进行拆分（fork）成若千个小任务（拆到不可再拆时），再将一个个的小任务运算的结果进行join汇总。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200404/ChkDGz2ekXrP.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;ForkJoin框架采用&lt;code&gt;工作窃取&lt;/code&gt;模式(work-stealing) :当执行新的任务时它可以将其拆分分成更小的任务执行，并将小任务加到线程队列中，然后再从一个随机线程的队列中偷一个并把它放在自己的队列中。&lt;/p&gt;
&lt;p&gt;相对于一般的线程池实现，fork/join框架的优势体现在对其中包含的任务的处理方式上，在一般的线程池中，如果一个线程正在执行的任务由于某些原因无法继续运行，那么该线程会处于等待状态。而在fork/join框架实现中，如果某个子问题由于等待另外一个子问题的完成而无法继续运行。那么处理该子问题的线程会主动寻找其他尚未运行的子问题来执行。这种方式减少了线程的等待时间，提高了性能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="并发编程" scheme="https://zouchanglin.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
      <category term="JUC" scheme="https://zouchanglin.cn/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>向新冠肺炎疫情牺牲烈士和逝世同胞深切哀悼</title>
    <link href="https://zouchanglin.cn/2020/04/04/%E5%90%91%E6%96%B0%E5%86%A0%E8%82%BA%E7%82%8E%E7%96%AB%E6%83%85%E7%89%BA%E7%89%B2%E7%83%88%E5%A3%AB%E5%92%8C%E9%80%9D%E4%B8%96%E5%90%8C%E8%83%9E%E6%B7%B1%E5%88%87%E5%93%80%E6%82%BC/"/>
    <id>https://zouchanglin.cn/2020/04/04/%E5%90%91%E6%96%B0%E5%86%A0%E8%82%BA%E7%82%8E%E7%96%AB%E6%83%85%E7%89%BA%E7%89%B2%E7%83%88%E5%A3%AB%E5%92%8C%E9%80%9D%E4%B8%96%E5%90%8C%E8%83%9E%E6%B7%B1%E5%88%87%E5%93%80%E6%82%BC/</id>
    <published>2020-04-04T02:00:00.000Z</published>
    <updated>2020-04-04T02:30:11.663Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200404/mGnvkmEckwD7.png&quot;
        
      
    
    </summary>
    
    
      <category term="生活" scheme="https://zouchanglin.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>虚假唤醒与Condition控制线程通信</title>
    <link href="https://zouchanglin.cn/2020/04/03/%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92%E4%B8%8ECondition%E6%8E%A7%E5%88%B6%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    <id>https://zouchanglin.cn/2020/04/03/%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92%E4%B8%8ECondition%E6%8E%A7%E5%88%B6%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/</id>
    <published>2020-04-03T03:01:35.000Z</published>
    <updated>2020-04-14T03:06:46.071Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200403/UurprEGkmsPn.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文通过生产者消费者模型主要讲述了什么是虚假唤醒，以及处理处理虚假唤醒。另外还使用了Condition 来控制线程间的通信，Condition接口描述了可能会与锁有关联的条件变量，这些变量在用法上与使用Object.wait 访问的隐式监视器类似，但提供了更强大的功能。需要特别指出的是，单个Lock 可能与多个Condition 对象关联。为了避免兼容性问题，Condition 方法的名称与对应的Object 版本中的不同。 在Condition 对象中，与wait、notify 和notifyAll 方法对应的分别是await、signal 和signalAll。 Condition允许发生虚假唤醒，这通常作为对基础平台语义的让步。不过Condition还是应该总是在一个循环中被等待，避免虚假唤醒的发生。&lt;/p&gt;
    
    </summary>
    
    
      <category term="并发编程" scheme="https://zouchanglin.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
      <category term="JUC" scheme="https://zouchanglin.cn/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>谈谈Java的线程池</title>
    <link href="https://zouchanglin.cn/2020/04/02/%E8%B0%88%E8%B0%88Java%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://zouchanglin.cn/2020/04/02/%E8%B0%88%E8%B0%88Java%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2020-04-02T09:01:35.000Z</published>
    <updated>2020-04-14T03:07:11.575Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200402/1RKDW9iG8m8Y.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文主要讲述了使用线程池的好处，Executors创建的五种线程池特点，简单介绍了Fork/Join框架。围绕Executor框架展开，阐述了线程池的工作流程，探讨了ThreadPoolExecutor的全部构造参数和意义，以及阿里巴巴不推荐使用Executors创建线程池的原因，另外，介绍了我们应该怎么样合理的创建线程池，对于CPU密集型和IO密集型以及混合型的创建方式。探讨了新任务提交后的执行流程，另外简单画了一下线程池生命周期图。&lt;/p&gt;
&lt;p&gt;Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或者并发执行任务的程序都可以使用线程池。开发&lt;br&gt;中使用线程池的三个优点如下：&lt;br&gt;1、降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁带来的消耗。&lt;br&gt;2、提高响应速度：当任务到达时，任务可以不需要等待线程创建就能立即执行。&lt;br&gt;3、提高线程的可管理性：使用线程池可以统一进行线程分配、调度和监控。&lt;/p&gt;
    
    </summary>
    
    
      <category term="并发编程" scheme="https://zouchanglin.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
      <category term="线程池" scheme="https://zouchanglin.cn/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>CAS操作与ABA问题</title>
    <link href="https://zouchanglin.cn/2020/04/02/CAS%E6%93%8D%E4%BD%9C%E4%B8%8EABA%E9%97%AE%E9%A2%98/"/>
    <id>https://zouchanglin.cn/2020/04/02/CAS%E6%93%8D%E4%BD%9C%E4%B8%8EABA%E9%97%AE%E9%A2%98/</id>
    <published>2020-04-02T06:01:35.000Z</published>
    <updated>2020-04-14T03:07:22.701Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;我们在使用锁时，线程获取锁是一种悲观锁策略，即假设每一次执行临界区代码都会产生冲突， 所以当前线程获取到锁的时候同时也会阻塞其他线程获取该锁。而CAS操作(又称为无锁操作)是一种乐观锁策略，它假设所有线程访问共享资源的时候不会出现冲突，既然不会出现冲突自然而然就不会阻塞其他线程的操作。因此，线程就不会出现阻塞停顿的状态。那么，如果出现冲突了怎么办？无锁操作是使用CAS(compare and swap)又叫做比较交换来鉴别线程是否出现冲突，出现冲突就重试当前操作直到没有冲突为止。&lt;/p&gt;
    
    </summary>
    
    
      <category term="并发编程" scheme="https://zouchanglin.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
      <category term="JUC" scheme="https://zouchanglin.cn/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantLock与AQS</title>
    <link href="https://zouchanglin.cn/2020/04/01/ReentrantLock%E4%B8%8EAQS/"/>
    <id>https://zouchanglin.cn/2020/04/01/ReentrantLock%E4%B8%8EAQS/</id>
    <published>2020-04-01T06:01:35.000Z</published>
    <updated>2020-04-14T03:07:34.507Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;synchronized和ReentrantLock的区别&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200402/jwuyI7Ai9jFH.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;先说说synchronized和ReentrantLock的区别吧，AQS的分析得等两天了：&lt;/p&gt;
&lt;p&gt;1、ReentrantLock (再入锁)，位于java.util.concurrent.locks包&lt;br&gt;2、和CountDownLatch、Future Task、Semaphore一样基于AQS实现&lt;br&gt;3、能够实现比synchronized更细粒度的控制，如控制公平与非公平&lt;br&gt;4、调用lock()之后，必须调用unlock()释放锁&lt;br&gt;5、性能未必比synchronized高，并且也是可重入的&lt;br&gt;6、synchronized是关键字，ReentrantLock是类&lt;br&gt;7、ReentrantLock可以对获取锁的等待时间进行设置，避免死锁的发生&lt;br&gt;8、ReentrantLock可以获取各种锁的信息&lt;br&gt;9、ReentrantLock可以灵活地实现多路通知&lt;br&gt;10、机制：sync操作Mark Word，lock调用Unsafe类的park()方法&lt;/p&gt;
    
    </summary>
    
    
      <category term="并发编程" scheme="https://zouchanglin.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
      <category term="JUC" scheme="https://zouchanglin.cn/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>synchronized实现与优化</title>
    <link href="https://zouchanglin.cn/2020/03/31/synchronized%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
    <id>https://zouchanglin.cn/2020/03/31/synchronized%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BC%98%E5%8C%96/</id>
    <published>2020-03-31T06:01:35.000Z</published>
    <updated>2020-04-14T03:07:55.710Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;本文主要讲述了synchronized的实现原理，还有synchronized的优化。其中主要包括了自适应自旋，锁消除、锁粗化、以及偏向锁和轻量级锁。另外阐述了锁的内存语义和对三种锁的总结。其实工程学科就是不断解决实际问题才能得以发展，synchronized从早期的一上来就直接使用Mutex逐步优化到现在的程度，mutex互斥量是最重要的同步原语，但是我们去使用mutex的时候却会出现诸多问题（比如销毁了已加锁的互斥量、死锁问题）Monitor机制是编程语言在语法上提供的语法糖，假设我们用的是C语言，那么很明显无法使用Monitor机制。&lt;/p&gt;
&lt;p&gt;很多文章笼统的说synchronized是基于Monitor机制实现的，我认为这是错误的说法，Monitor 机制必须要有临界区、Monitor对象和互斥量、条件变量和wait()、signal()等要素。在synchronized的实现中根本找不到所有对应的元素。我认为Java的Monitor机制包括了synchronized、Object和程序员自己定的条件变量等（因为我们通常使用wait()、 notify()、notifyAll()配合synchronized才能取解决生产者消费者问题），这才一套完整的Monitor机制。JVM的ObjectMonitor用来辅助Java实现Monitor机制，直接把JVM的ObjectMonitor当成Monitor机制是不可取的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="并发编程" scheme="https://zouchanglin.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
      <category term="多线程" scheme="https://zouchanglin.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>synchronized锁的是什么</title>
    <link href="https://zouchanglin.cn/2020/03/28/synchronized%E9%94%81%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>https://zouchanglin.cn/2020/03/28/synchronized%E9%94%81%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88/</id>
    <published>2020-03-28T06:01:35.000Z</published>
    <updated>2020-04-14T03:08:08.324Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;最近发现synchronized锁的是什么？甚至有人认为synchronized锁的是代码？？！这个我觉得还是很有必要通过实际的示例来说明synchronized锁的到底是什么。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;根据获取的锁的分类：获取对象锁和获取类锁！&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;获取对象锁的两种用法&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、同步代码块(synchronized(this), synchronized(类实例对象))，锁是小括号()中的实例对象。&lt;br&gt;2、同步非静态方法(synchronized method)，锁是当前对象的实例对象。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;获取类锁的两种用法&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、同步代码块(synchronized(类.class))，锁是小括号()中的类对象，即Class对象。&lt;br&gt;2、同步静态方法(synchronized static method)，锁是当前对象的类对象(Class对象)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="并发编程" scheme="https://zouchanglin.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
      <category term="多线程" scheme="https://zouchanglin.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程相关的基础问题</title>
    <link href="https://zouchanglin.cn/2020/03/23/%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98/"/>
    <id>https://zouchanglin.cn/2020/03/23/%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98/</id>
    <published>2020-03-23T06:01:35.000Z</published>
    <updated>2020-04-14T03:08:18.954Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200324/n0eEP9zdhKzQ.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文主要讲述了进程和线程发展简史，对于JVM来讲的进程和线程又是什么，Thread的start()方法的原生调用发生了什么，从而理解start()方法和run()方法有什么不同，另外，还介绍了三种处理线程执行完成后的返回值的方法，其实FutureTask和线程池获取线程执行结束的返回值更加常用。另外，介绍了线程的六种状态，还有sleep和wait的区别，notify和notifyAll的区别，yield函数的作用，以及如何优雅的中断线程等问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="并发编程" scheme="https://zouchanglin.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
      <category term="多线程" scheme="https://zouchanglin.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>
