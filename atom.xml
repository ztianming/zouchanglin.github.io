<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tim&#39;s Blog</title>
  
  <subtitle>当你凝望深渊时，深渊也在凝望你</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zouchanglin.cn/"/>
  <updated>2020-03-28T11:07:04.665Z</updated>
  <id>https://zouchanglin.cn/</id>
  
  <author>
    <name>changlin zou</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>synchronized锁的是什么</title>
    <link href="https://zouchanglin.cn/2020/03/28/synchronized%E9%94%81%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>https://zouchanglin.cn/2020/03/28/synchronized%E9%94%81%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88/</id>
    <published>2020-03-28T06:01:35.000Z</published>
    <updated>2020-03-28T11:07:04.665Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;最近发现synchronized锁的是什么？甚至有人认为synchronized锁的是代码？？！这个我觉得还是很有必要通过实际的示例来说明synchronized锁的到底是什么。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;根据获取的锁的分类：获取对象锁和获取类锁！&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;获取对象锁的两种用法&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、同步代码块(synchronized(this), synchronized(类实例对象))，锁是小括号()中的实例对象。&lt;br&gt;2、同步非静态方法(synchronized method)，锁是当前对象的实例对象。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;获取类锁的两种用法&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、同步代码块(synchronized(类.class))，锁是小括号()中的类对象，即Class对象。&lt;br&gt;2、同步静态方法(synchronized static method)，锁是当前对象的类对象(Class对象)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="并发编程" scheme="https://zouchanglin.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>线程相关的基础问题</title>
    <link href="https://zouchanglin.cn/2020/03/23/%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98/"/>
    <id>https://zouchanglin.cn/2020/03/23/%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98/</id>
    <published>2020-03-23T06:01:35.000Z</published>
    <updated>2020-03-25T05:15:21.742Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200324/n0eEP9zdhKzQ.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文主要讲述了进程和线程发展简史，对于JVM来讲的进程和线程又是什么，Thread的start()方法的原生调用发生了什么，从而理解start()方法和run()方法有什么不同，另外，还介绍了三种处理线程执行完成后的返回值的方法，其实FutureTask和线程池获取线程执行结束的返回值更加常用。另外，介绍了线程的六种状态，还有sleep和wait的区别，notify和notifyAll的区别，yield函数的作用，以及如何优雅的中断线程等问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="并发编程" scheme="https://zouchanglin.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>OkHttp的使用与跳坑示例</title>
    <link href="https://zouchanglin.cn/2020/03/22/OkHttp%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%B7%B3%E5%9D%91%E7%A4%BA%E4%BE%8B/"/>
    <id>https://zouchanglin.cn/2020/03/22/OkHttp%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%B7%B3%E5%9D%91%E7%A4%BA%E4%BE%8B/</id>
    <published>2020-03-22T06:01:35.000Z</published>
    <updated>2020-03-22T10:10:08.524Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200322/4XcsC1Ht6x4l.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;OkHttp是一个优秀的网络请求框架，我开始接触Android开发的时候就用过这个网络请求框架，官方的参考文档在这里  &lt;a href=&quot;https://square.github.io/okhttp/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://square.github.io/okhttp/&lt;/a&gt; ，本文演示了使用OkHttp框架进行简单的Get、Post（表单形式和JSON形式）、Delete、附加请求头、请求异步回调，文件的上传和下载等常用操作。最后记录了一个今天调试了很久的坑，那就是response.body().string()只能有效调用一次，注意Debug的时候对结果造成的改变！JDK9的HttpURLConnection有很多变化，下次博客中会有演示和说明。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web开发" scheme="https://zouchanglin.cn/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaWeb" scheme="https://zouchanglin.cn/tags/JavaWeb/"/>
    
      <category term="异步" scheme="https://zouchanglin.cn/tags/%E5%BC%82%E6%AD%A5/"/>
    
      <category term="上传下载" scheme="https://zouchanglin.cn/tags/%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>Docker私服配置HTTPS</title>
    <link href="https://zouchanglin.cn/2020/03/21/Docker%E7%A7%81%E6%9C%8D%E9%85%8D%E7%BD%AEHTTPS/"/>
    <id>https://zouchanglin.cn/2020/03/21/Docker%E7%A7%81%E6%9C%8D%E9%85%8D%E7%BD%AEHTTPS/</id>
    <published>2020-03-21T06:01:35.000Z</published>
    <updated>2020-03-21T12:45:25.313Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200321/vL5w2LvCRPhV.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图即使我搭建完毕的效果。对于Docker的环境安装，基础命令之类的内容，通读官网文档内容基本都能顺利掌握。 然而，当笔者尝试着搭建一套基于SSL的Docker Registry（官网推荐的做法）却遇到了不少的麻烦，对于这部分内容，大多数博客文档内容都是直接跳过了SSL的环节，采用了HTTP的访问形式。 然而本文就是记录一下对于搭建HTTPS 访问形式的Docker Registry的过程，读者很容易复现的过程！&lt;/p&gt;
&lt;p&gt;我的环境是CentOS7_x64，Docker版本是 Client: Docker Engine - Community 19.03.7、Server: Docker Engine - Community 19.03.7、Nginx源码包的版本是nginx-1.9.9.tar.gz。&lt;/p&gt;
    
    </summary>
    
    
      <category term="虚拟化技术" scheme="https://zouchanglin.cn/categories/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Docker" scheme="https://zouchanglin.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>优雅的实现单例</title>
    <link href="https://zouchanglin.cn/2020/03/18/%E4%BC%98%E9%9B%85%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B/"/>
    <id>https://zouchanglin.cn/2020/03/18/%E4%BC%98%E9%9B%85%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B/</id>
    <published>2020-03-18T06:01:35.000Z</published>
    <updated>2020-03-18T15:52:17.775Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;单例模式属于创建型设计模式，一个类在虚拟机中只有一份实例。实现单例模式的核心思想在于构造函数私有化，主要实现方式分为两种：懒汉式和饿汉式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200318/uUtN2uPGYzCk.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://zouchanglin.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
      <category term="JVM" scheme="https://zouchanglin.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java的四种引用</title>
    <link href="https://zouchanglin.cn/2020/03/15/Java%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8/"/>
    <id>https://zouchanglin.cn/2020/03/15/Java%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8/</id>
    <published>2020-03-15T06:01:35.000Z</published>
    <updated>2020-03-17T12:25:06.404Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200316/mALYmfXLzFOP.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;在Java语言中，除了原始数据类型的变量，其他所有都是所谓的引用类型，指向各种不同的对象，理解引用对于掌握Java对象生命周期和JVM内部相关机制非常有帮助。本文讲述了强引用、软引用、弱引用、幻象引用的区别以及一些具体使用场景，而且是配合ReferenceQueue使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="https://zouchanglin.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
      <category term="JVM" scheme="https://zouchanglin.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>请丢弃finalize</title>
    <link href="https://zouchanglin.cn/2020/03/15/%E8%AF%B7%E4%B8%A2%E5%BC%83finalize/"/>
    <id>https://zouchanglin.cn/2020/03/15/%E8%AF%B7%E4%B8%A2%E5%BC%83finalize/</id>
    <published>2020-03-14T23:01:35.000Z</published>
    <updated>2020-03-17T04:39:38.664Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;用过JDK9的同学应该发现了，finalize方法在JDK9中已经被标记为deprecated，今天探讨一下finalize方法。如果没有特别的原因，不要实现finalize方法，也不要指望利用它来进行资源回收。因为你无法保证finalize什么时候执行，执行的是否符合预期。使用不当会影响性能，导致程序死锁、挂起等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="https://zouchanglin.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
      <category term="JVM" scheme="https://zouchanglin.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>9种垃圾收集器</title>
    <link href="https://zouchanglin.cn/2020/03/12/9%E7%A7%8D%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>https://zouchanglin.cn/2020/03/12/9%E7%A7%8D%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</id>
    <published>2020-03-11T23:01:35.000Z</published>
    <updated>2020-03-13T03:06:29.627Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200312/5dC8XXcmBoUn.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;目前的垃圾收集器主要有7种，上图是他们的使用关系，连在一起的就可以配合使用。JDK11出现两种新的垃圾收集器，一个是Epsilon垃圾收集器，一个是ZGC垃圾收集器。垃圾收集器中很重要的两个概念：Stop-The-World和Safepoint。首先说说Stop-The-World：JVM由于要执行GC而停止了应用程序的执行，任何一种GC算法中都会发生。多数GC优化通过减少Stop-the -world发生的时间来提高程序性能。安全点 Safepoint：分析过程中对象引用关系不会发生变化的点，产生Safepoint的地方：方法调用、循环跳转、异常跳转等，安全点数量得适中。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="https://zouchanglin.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
      <category term="JVM" scheme="https://zouchanglin.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>垃圾标记与收集算法</title>
    <link href="https://zouchanglin.cn/2020/03/11/%E5%9E%83%E5%9C%BE%E6%A0%87%E8%AE%B0%E4%B8%8E%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/"/>
    <id>https://zouchanglin.cn/2020/03/11/%E5%9E%83%E5%9C%BE%E6%A0%87%E8%AE%B0%E4%B8%8E%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/</id>
    <published>2020-03-10T23:01:35.000Z</published>
    <updated>2020-03-13T03:06:29.731Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;本文主要是以通俗易懂的画图方式解释了标记清除算法和可达性分析算法，以及常用的回收算法（标记清除、标记整理、复制算法）以及整合百家之长的分代回收算法，另外还介绍了触发Full GC的几个场景。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="https://zouchanglin.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
      <category term="JVM" scheme="https://zouchanglin.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型的回顾</title>
    <link href="https://zouchanglin.cn/2020/03/10/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%9B%9E%E9%A1%BE/"/>
    <id>https://zouchanglin.cn/2020/03/10/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%9B%9E%E9%A1%BE/</id>
    <published>2020-03-09T23:01:35.000Z</published>
    <updated>2020-03-13T03:06:29.664Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200310/6jem5nNs1Jug.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;本篇文章主要讲述了Java内存模型中的程序计数器、虚拟机栈、本地方法栈、元空间与堆，以及堆中的常量池。前面通过javap反编译class文件得到&lt;code&gt;int add(int a, int b)&lt;/code&gt;函数的栈帧，主要分析了栈帧中JVM指令对应的局部变量表、操作数栈、程序计数器的状态变化。以及JDK7以后出现了替代永久代的元数据区，并分析了元数据区替换了永久代有哪些好处，主要分析了给字符串常量池带来的影响，并通过代码验证了元数据区相比永久代的优越性。学习了JVM性能调优的三个参数的意义和普通用法，最后探讨了并验证了JDK1.6与JDK1.7+的版本String类的intern方法的不同表现结果，分析了出现不同结果的原因，其实主要是JDK1.6的版本是建立副本再放入字符串常量池，而JDK1.7+版本时直接把堆上的对象的引用入池。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="https://zouchanglin.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
      <category term="JVM" scheme="https://zouchanglin.cn/tags/JVM/"/>
    
      <category term="字符串" scheme="https://zouchanglin.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>ClassLoader</title>
    <link href="https://zouchanglin.cn/2020/03/08/ClassLoader/"/>
    <id>https://zouchanglin.cn/2020/03/08/ClassLoader/</id>
    <published>2020-03-07T23:01:35.000Z</published>
    <updated>2020-03-13T03:06:29.642Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200308/Tyosik8F2e9b.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;ClassLoader在Java中有着非常重要的作用，它主要工作在Class装载的加载阶段，其主要作用是从系统外部获得Class二进制数据流。它是Java的核心组件。所有的Class都是由ClassLoader 进行加载的。ClassLoader负责通过将Class文件里的二进制数据流装载进系统，然后交给Java虚拟机进行连接、初始化等操作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="https://zouchanglin.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
      <category term="JVM" scheme="https://zouchanglin.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>图解epoll原理</title>
    <link href="https://zouchanglin.cn/2020/03/01/%E5%9B%BE%E8%A7%A3epoll%E5%8E%9F%E7%90%86/"/>
    <id>https://zouchanglin.cn/2020/03/01/%E5%9B%BE%E8%A7%A3epoll%E5%8E%9F%E7%90%86/</id>
    <published>2020-03-01T12:01:35.000Z</published>
    <updated>2020-03-13T03:06:29.730Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200301/wtDoDUaxYAlG.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;poll翻译过来是轮询的意思， 可以看到poll和epoll都有轮询的过程， 不同点在于：poll轮询的是所有的socket，而epoll只轮询就绪的socket。 epoll是开发linux高性能服务器的必备技术至，epoll本质，是服务端程序员的必须掌握的知识。 本文主要是利用图文讲述了select的原理和epoll相对于做出的优化，以及epoll的部分细节问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="高性能网络" scheme="https://zouchanglin.cn/categories/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Linux" scheme="https://zouchanglin.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>select、poll和epoll多路复用</title>
    <link href="https://zouchanglin.cn/2020/02/29/select%E3%80%81poll%E5%92%8Cepoll%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    <id>https://zouchanglin.cn/2020/02/29/select%E3%80%81poll%E5%92%8Cepoll%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</id>
    <published>2020-02-29T12:01:35.000Z</published>
    <updated>2020-03-13T03:06:29.704Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200301/EQNj1T6uKbOU.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;Nginx和Redis中都用到了epoll多路复用模型，本节将讲述常见的多路复用模型：select、poll和epoll，以及部分示例代码，还是先回顾IO的两个重要过程：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;任何IO过程中，都包含两个步骤：第一是等待，第二是拷贝。而且在实际的应用场景中，等待消耗的时间往往都远远高于拷贝的时间。让IO更高效，最核心的办法就是让等待的时间尽量少。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在以前的文章中介绍了五种IO模型，分别是阻塞式IO、非阻塞式IO、信号驱动IO、多路复用IO、异步IO；前四种都属于同步IO。今天重点介绍的是多路复用IO，多路复用IO通俗讲就是一次等待多个文件描述符，减少了等待时间，提高了IO过程的效率（此IO过程并不是只是从内核态到用户态数据的拷贝，而是从发起IO请求直到IO完成的过程），接下来将介绍Linux的三种多路复用模型。&lt;/p&gt;
    
    </summary>
    
    
      <category term="高性能网络" scheme="https://zouchanglin.cn/categories/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Linux" scheme="https://zouchanglin.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>通俗理解五种IO模型</title>
    <link href="https://zouchanglin.cn/2020/02/29/%E9%80%9A%E4%BF%97%E7%90%86%E8%A7%A3%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/"/>
    <id>https://zouchanglin.cn/2020/02/29/%E9%80%9A%E4%BF%97%E7%90%86%E8%A7%A3%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-02-29T12:01:35.000Z</published>
    <updated>2020-03-13T03:06:29.774Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200229/JzUvCzR8JTH3.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;任何IO过程中，都包含两个步骤：第一是等待，第二是拷贝。而且在实际的应用场景中，等待消耗的时间往往都远远高于拷贝的时间。让IO更高效，最核心的办法就是让等待的时间尽量少。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="高性能网络" scheme="https://zouchanglin.cn/categories/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Linux" scheme="https://zouchanglin.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Redis的常见问题</title>
    <link href="https://zouchanglin.cn/2020/02/28/Redis%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>https://zouchanglin.cn/2020/02/28/Redis%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</id>
    <published>2020-02-28T12:01:35.000Z</published>
    <updated>2020-03-13T03:06:29.703Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Redis最常用的数据类型有String类型、Hash、List、Set、SortedSet（分数控制的有序Set）。&lt;br&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200307/gsrpCh9AXzc9.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://zouchanglin.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Redis" scheme="https://zouchanglin.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB秒级快照原理与当前读</title>
    <link href="https://zouchanglin.cn/2020/02/27/InnoDB%E7%A7%92%E7%BA%A7%E5%BF%AB%E7%85%A7%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BD%93%E5%89%8D%E8%AF%BB/"/>
    <id>https://zouchanglin.cn/2020/02/27/InnoDB%E7%A7%92%E7%BA%A7%E5%BF%AB%E7%85%A7%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BD%93%E5%89%8D%E8%AF%BB/</id>
    <published>2020-02-27T12:01:35.000Z</published>
    <updated>2020-03-13T03:06:29.661Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200227/9xbkj74TxjVu.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;在之前为文章&lt;a href=&quot;https://zouchanglin.cn/2020/02/26/分析事务隔离的实现&quot;&gt;《分析事务隔离的实现》&lt;/a&gt;中我们提到：如果是可重复读隔离级别，事务T启动的时候会创建一个视图 read-view，之后事务 T 执行期间，即使有其他事务修改了数据，事务 T 看到的仍然跟在启动时看到的一样。也就是说，一个在可重复读隔离级别下执行的事务，好像与世无争，不受外界影响。但是，我在介绍MySQL锁机制的文章中&lt;a href=&quot;https://zouchanglin.cn/2019/10/25/探究MySQL锁机制&quot;&gt;《探究MySQL锁机制》&lt;/a&gt; 的时候，一个事务要更新一行，如果刚好有另外一个事务拥有这一行的行锁，它会被锁住，进入等待状态。问题是，既然进入了等待状态，那么等到这个事务自己获取到行锁要更新数据的时候，它读到的值又是什么呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://zouchanglin.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://zouchanglin.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>分析事务隔离的实现</title>
    <link href="https://zouchanglin.cn/2020/02/27/%E5%88%86%E6%9E%90%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://zouchanglin.cn/2020/02/27/%E5%88%86%E6%9E%90%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-02-27T00:01:35.000Z</published>
    <updated>2020-03-13T03:06:29.724Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200227/a3pBOiztLcnN.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;关于MySQL的锁机制问题，在之前的博客中有谈到&lt;a href=&quot;https://zouchanglin.cn/2019/10/25/探究MySQL锁机制&quot;&gt;《探究MySQL锁机制》&lt;/a&gt; ，里面对锁的讲解比较详细，现在是在原来的基础上谈谈数据库事务相关的问题。简单来说事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在MySQL中，事务支持是在引擎层实现的。你现在知道，MySQL是一个支持多引擎的系统，但并不是所有的引|擎都支持事务。比如MySQL原生的MyISAM引擎就不支持事务，这也是MyISAM被InnoDB取代的重要原因之一。首先要知道的是数据库事务四大特性：ACID&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://zouchanglin.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://zouchanglin.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>密集索引和稀疏索引</title>
    <link href="https://zouchanglin.cn/2020/02/26/%E5%AF%86%E9%9B%86%E7%B4%A2%E5%BC%95%E5%92%8C%E7%A8%80%E7%96%8F%E7%B4%A2%E5%BC%95/"/>
    <id>https://zouchanglin.cn/2020/02/26/%E5%AF%86%E9%9B%86%E7%B4%A2%E5%BC%95%E5%92%8C%E7%A8%80%E7%96%8F%E7%B4%A2%E5%BC%95/</id>
    <published>2020-02-26T12:01:35.000Z</published>
    <updated>2020-03-13T03:06:29.735Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;密集索引：文件中的每个搜索码值都对应一个索引值，就是叶子节点保存了整行，比如InnoDB&lt;/p&gt;
&lt;p&gt;稀疏索引：文件只为索引码的某些值建立索引项，比如MyISAM&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200226/L4dIVF9GX4Si.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;密集索引的表数据按顺序存储，即索引顺序和表记录物理存储顺序一致，所以一个表只能创建一个密集索引&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://zouchanglin.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="索引" scheme="https://zouchanglin.cn/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="MySQL" scheme="https://zouchanglin.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>BTree与B+Tree</title>
    <link href="https://zouchanglin.cn/2020/02/26/BTree%E4%B8%8EB+Tree/"/>
    <id>https://zouchanglin.cn/2020/02/26/BTree%E4%B8%8EB+Tree/</id>
    <published>2020-02-26T11:01:35.000Z</published>
    <updated>2020-03-13T03:06:29.631Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;其实在之前的文章说说到过MySQL索引，只不过没细说，&lt;a href=&quot;https://zouchanglin.cn/2019/09/12/JOIN查询与索引简介/#5、MySQL索引结构&quot;&gt;《JOIN查询与索引简介》&lt;/a&gt; ，现在来看看回顾一下索引相关的数据结构，首先看看索引的定义： 索引(Index)是帮助MySQL高效获取数据的数据结构。 我不会索引就是类似于字典这样的话泛泛而谈，而是如何真正去理解索引。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://zouchanglin.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="索引" scheme="https://zouchanglin.cn/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="MySQL" scheme="https://zouchanglin.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS协议实现原理</title>
    <link href="https://zouchanglin.cn/2020/02/25/HTTPS%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://zouchanglin.cn/2020/02/25/HTTPS%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2020-02-25T11:01:35.000Z</published>
    <updated>2020-03-13T03:06:29.659Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200225/meVCCACO399R.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;HTTP协议的信息传输完全以明文方式，不做任何加密，相当于是在网络上”裸奔”。意思就是如果我们以HTTP来传输数据的话由于是明文数据，则很容易发生不安全事故，比如我登陆一个网站，那么如果是HTTP明文传输肯定就会直接把用户名和密码放在明文中，这样是非常不安全的，处在同一个局域网下的小伙伴直接抓包就可以获取你的用户名和密码，那么应该怎么办呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://zouchanglin.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://zouchanglin.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="网络安全" scheme="https://zouchanglin.cn/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
      <category term="非对称加密" scheme="https://zouchanglin.cn/tags/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
</feed>
