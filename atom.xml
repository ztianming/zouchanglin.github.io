<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tim&#39;s Blog</title>
  
  <subtitle>加油，冲冲冲...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zouchanglin.cn/"/>
  <updated>2020-04-23T11:48:46.816Z</updated>
  <id>https://zouchanglin.cn/</id>
  
  <author>
    <name>邹长林</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>什么是可中断锁</title>
    <link href="https://zouchanglin.cn/2020/04/23/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E4%B8%AD%E6%96%AD%E9%94%81/"/>
    <id>https://zouchanglin.cn/2020/04/23/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E4%B8%AD%E6%96%AD%E9%94%81/</id>
    <published>2020-04-23T10:00:00.000Z</published>
    <updated>2020-04-23T11:48:46.816Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Lock是可中断锁，而synchronized不是可中断锁。现假设线程A和B都要获取对象O的锁定，假设A获取了对象O锁，B将等待A释放对O的锁定，如果使用synchronized，如果A不释放，B将一直等下去，不能被中断；如果使用ReentrantLock，如果A不释放，可以使B在等待了足够长的时间以后，中断等待，而干别的事情。获取锁超时机制还是属于不可中断，属于超时被动放弃去竞争锁，而lockInterruptibly是可主动放弃竞争锁行为的一种方式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="并发编程" scheme="https://zouchanglin.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>JDK11新特性</title>
    <link href="https://zouchanglin.cn/2020/04/17/JDK11%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://zouchanglin.cn/2020/04/17/JDK11%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2020-04-17T10:00:00.000Z</published>
    <updated>2020-04-20T06:14:53.785Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Oracle官方于2018年9月26日宣布Java11正式发布。目前Oracle 官方也已经宣布Java11正式可以商用，这是Java 大版本周期变化后的第一个长期支持版本，非常值得关注。最新发布的Java11一共包含17个JEP（JDK Enhancement Proposals，JDK 增强提案）。对于企业来说，选择Java11将意味着长期的、可靠的、可预测的技术路线图。其中免费的OpenJDK11确定将得到OpenJDK社区的长期支持，LTS版本将是可以放心选择的版本。由于JDK9和JDK10都是一个过渡版本，JDK11的特性是在JDK9中就有的，我在博客里也做了总结&lt;a href=&quot;https://zouchanglin.cn/2020/04/15/JDK9新特性(一)&quot;&gt;《 JDK9新特性(一)》&lt;/a&gt;， &lt;a href=&quot;https://zouchanglin.cn/2020/04/16/JDK9新特性(二)&quot;&gt;《JDK9新特性(二)》&lt;/a&gt; ，其中已经介绍过的新特性将不会在这篇文章出现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="https://zouchanglin.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
      <category term="GC" scheme="https://zouchanglin.cn/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>JDK9新特性(二)</title>
    <link href="https://zouchanglin.cn/2020/04/16/JDK9%E6%96%B0%E7%89%B9%E6%80%A7(%E4%BA%8C)/"/>
    <id>https://zouchanglin.cn/2020/04/16/JDK9%E6%96%B0%E7%89%B9%E6%80%A7(%E4%BA%8C)/</id>
    <published>2020-04-16T10:00:00.000Z</published>
    <updated>2020-04-19T12:09:02.919Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇的文章我记述了JDK9的两个最重要的特性：一个是模块化，一个是jShell。另外就是String底层存储结构和StreamAPI的一些改动与优化。本次要记述主要的特性是全新的多分辨率图像API、全新的HTTP客户端API（其实是借鉴OkHTTP的框架，或者说是整合吧）、Deprecated相关API、智能Java编译工具与动态编译器、统一的JVM日志系统、javadoc对H5的支持、JavaScript引擎升级：Nashorn。然后再谈谈JDK9还需要什么吧，也就是对未来Java的展望。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="https://zouchanglin.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
      <category term="模块化" scheme="https://zouchanglin.cn/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
      <category term="交互式" scheme="https://zouchanglin.cn/tags/%E4%BA%A4%E4%BA%92%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JDK9新特性(一)</title>
    <link href="https://zouchanglin.cn/2020/04/15/JDK9%E6%96%B0%E7%89%B9%E6%80%A7(%E4%B8%80)/"/>
    <id>https://zouchanglin.cn/2020/04/15/JDK9%E6%96%B0%E7%89%B9%E6%80%A7(%E4%B8%80)/</id>
    <published>2020-04-15T10:00:00.000Z</published>
    <updated>2020-04-20T03:26:49.452Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Java8在2014年3月份推出的，而历经曲折的Java9终于终于在2017年9月21日发布，中间历经3年多时间，Java9提供了超过150项新功能特性，包括备受期待的模块化系统、可交互的 REPL 工具：jshell，JDK 编译工具，Java 公共 API 和私有代码，以及安全增强、扩展提升、性能管理改善等。可以说Java 9是一个庞大的系统工程，完全做了一个整体改变。Java8中最核心的新特性就是Lambda表达式和Stream API，那么对于Java9来说其中最核心莫过于模块化系统和JShell命令。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="https://zouchanglin.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
      <category term="模块化" scheme="https://zouchanglin.cn/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
      <category term="交互式" scheme="https://zouchanglin.cn/tags/%E4%BA%A4%E4%BA%92%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JDK8新特性</title>
    <link href="https://zouchanglin.cn/2020/04/14/JDK8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://zouchanglin.cn/2020/04/14/JDK8%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2020-04-14T10:00:00.000Z</published>
    <updated>2020-04-17T04:07:16.105Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;虽然已经用过了一些Java8的新特性，但是总来没有仔细总结一下。Java8自从2014年就发布了，到目前为止只有一小部分公司在用JDK7及其以下的版本，大部分已经迁移至Java8，甚至Java11（关于Java9和Java11的特性我会在之后两篇文章中记述），目前只看Java8那些最主要的、也是最常用的新特性，我到目前为止用到的最多的也就是Stream API和Lambda表达式，新时间日期的API也比较常用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="https://zouchanglin.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
      <category term="Stream" scheme="https://zouchanglin.cn/tags/Stream/"/>
    
      <category term="Lambda" scheme="https://zouchanglin.cn/tags/Lambda/"/>
    
  </entry>
  
  <entry>
    <title>堆的实现及其应用</title>
    <link href="https://zouchanglin.cn/2020/04/13/%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"/>
    <id>https://zouchanglin.cn/2020/04/13/%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</id>
    <published>2020-04-13T10:00:00.000Z</published>
    <updated>2020-04-21T10:20:16.416Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章记述的是堆排序，这个名字看起来好像又要介绍一个排序算法，但是排序算法是次要的，主要的是一个数据结构——堆。堆排序问题就是堆这种数据结构所衍生出来的一个应用，我们先了解一下优先队列的概念。普通的队列就是满足先进先出、后进后出的一个结构。那么优先级队列呢？出队顺序和入队顺序无关，和优先级相关，这就比如在医院看病，肯定是急诊病人优先看病。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://zouchanglin.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="https://zouchanglin.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
      <category term="堆" scheme="https://zouchanglin.cn/tags/%E5%A0%86/"/>
    
      <category term="二叉树" scheme="https://zouchanglin.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>注解的原理与实现</title>
    <link href="https://zouchanglin.cn/2020/04/12/%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>https://zouchanglin.cn/2020/04/12/%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-04-12T10:00:00.000Z</published>
    <updated>2020-04-15T06:04:25.034Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;注解这个东西自从SpringBoot以来一直是Java开发者们必备的生存技巧呀，我们平时几乎大部分时间都是面向注解编程，通过注解我们可以节约大量的时间。用过了这么多的注解，那么我们否有关注过注解的实现原理呢？所以本篇文章主要是讲述注解的有关操作，自己实现一个注解来体会注解的实现原理，注解也不是特别高深的东西，掌握了自然就明白了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="https://zouchanglin.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="JavaWeb" scheme="https://zouchanglin.cn/tags/JavaWeb/"/>
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
      <category term="JavaEE" scheme="https://zouchanglin.cn/tags/JavaEE/"/>
    
  </entry>
  
  <entry>
    <title>关于快排和归并的思考</title>
    <link href="https://zouchanglin.cn/2020/04/11/%E5%85%B3%E4%BA%8E%E5%BF%AB%E6%8E%92%E5%92%8C%E5%BD%92%E5%B9%B6%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>https://zouchanglin.cn/2020/04/11/%E5%85%B3%E4%BA%8E%E5%BF%AB%E6%8E%92%E5%92%8C%E5%BD%92%E5%B9%B6%E7%9A%84%E6%80%9D%E8%80%83/</id>
    <published>2020-04-11T10:00:00.000Z</published>
    <updated>2020-04-14T12:01:02.853Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;归并排序和快速排序是两种稍微复杂的排序算法，它们用的都是分治的思想，代码都通过递归来实现，过程非常相似。归并排序算法是一种在任何情况下时间复杂度都比较稳定的排序算法，这也使它存在致命的缺点，即归并排序不是原地排序算法，空间复杂度比较高，是 O(n)。正因为此它也没有快排应用广泛。快速排序算法虽然最坏情况下的时间复杂度是 O(n²)，但是平均情况下时间复杂度都是 O(nlogn)。且快速排序算法时间复杂度退化到 O(n²) 的概率非常小，我们可以通过合理地选择基准值来避免这种情况。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://zouchanglin.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="https://zouchanglin.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>快速排序及其优化</title>
    <link href="https://zouchanglin.cn/2020/04/10/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"/>
    <id>https://zouchanglin.cn/2020/04/10/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/</id>
    <published>2020-04-10T10:00:00.000Z</published>
    <updated>2020-04-14T10:06:23.620Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;快速排序(Quick Sort)被称为20世纪对世界影响最大的算法之一，现在我们来看快速排序算法，习惯性把它简称为快排，快排利用的也是分治思想。乍看起来，它有点像归并排序，但是思路其实完全不一样。现在，我们先来看下快排的核心思想，最后将讲述快速排序的两个优化方案，其实还有一种三路快排的优化方案也是可以的，但是本片文章重点在于快速排序的原理和实现，所以三路快排的优化方案不会出现在这篇文章里，以后再详细记录一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://zouchanglin.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="https://zouchanglin.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>O(nLogn)的归并排序</title>
    <link href="https://zouchanglin.cn/2020/04/09/O(nLogn)%E7%9A%84%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>https://zouchanglin.cn/2020/04/09/O(nLogn)%E7%9A%84%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</id>
    <published>2020-04-09T10:00:00.000Z</published>
    <updated>2020-04-12T01:13:31.777Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;之前几篇文章我介绍了三种O(n²)的排序算法&lt;a href=&quot;https://zouchanglin.cn/2020/04/07/O(n²)的三个排序算法&quot;&gt;《O(n²)的三个排序算法》&lt;/a&gt;（选择排序、插入排序和冒泡排序）以及它们的优化，然后顺便还写了一篇希尔排序的文章&lt;a href=&quot;https://zouchanglin.cn/2020/04/09/插入排序的优化之希尔排序&quot;&gt;《插入排序的优化之希尔排序》&lt;/a&gt;，但是其实用的比较多的还是直接插入排序，它们比较适合于小规模数据的排序 。下面我将记录时间复杂度为nlog(n)的几种排序算法之一 —— 归并排序算法，这种排序算法适合大规模的数据排序，比之前的O(n²)的三种排序算法更为常用，在学习之前我们可以先对比一下nlog(n)和n²是什么概念。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://zouchanglin.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="https://zouchanglin.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>插入排序的优化之希尔排序</title>
    <link href="https://zouchanglin.cn/2020/04/09/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BC%98%E5%8C%96%E4%B9%8B%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    <id>https://zouchanglin.cn/2020/04/09/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BC%98%E5%8C%96%E4%B9%8B%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</id>
    <published>2020-04-09T03:00:00.000Z</published>
    <updated>2020-04-09T04:42:28.387Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;希尔排序是插入排序的一种，又称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法，可以说它是插入排序的高级版。我们可以先回顾一下直接插入排序的过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200408/epYKaCrsQqxV.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;排序前将第一个元素看成有序的数列&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第1趟排序后：得到一个长度为2的有序数列&lt;/li&gt;
&lt;li&gt;第2趟排序后：得到一个长度为3的有序数列&lt;/li&gt;
&lt;li&gt;第3趟排序后：得到一个长度为4的有序数列&lt;/li&gt;
&lt;li&gt;……..每趟插入排序，都可以将一个无序值插入一个有序数列，直到全部元素有序&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://zouchanglin.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="https://zouchanglin.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>O(n²)的三个排序算法</title>
    <link href="https://zouchanglin.cn/2020/04/07/O(n%C2%B2)%E7%9A%84%E4%B8%89%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://zouchanglin.cn/2020/04/07/O(n%C2%B2)%E7%9A%84%E4%B8%89%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2020-04-07T10:00:00.000Z</published>
    <updated>2020-04-10T01:41:15.470Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;今天复习下最简单的三个排序算法，一个是选择排序，一个是插入排序，一个是冒泡排序，三者时间复杂度都是O(n²)，通过分析来发现三者的优劣，以及对最好的情况和最坏的情况进行分析。 另外，这三中排序算法都是基于比较的排序算法。基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。所以，如果我们在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://zouchanglin.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="https://zouchanglin.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>SpringIOC原理与应用</title>
    <link href="https://zouchanglin.cn/2020/04/05/SpringIOC%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <id>https://zouchanglin.cn/2020/04/05/SpringIOC%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/</id>
    <published>2020-04-05T10:00:00.000Z</published>
    <updated>2020-04-14T03:02:16.327Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200405/HbNPDVawlHpU.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;ICO容器的结构如上图所示，首先要让IOC容器去读取Bean的配置信息，并在容器中生成一份相应的Bean定义注册表，根据这张注册表去实例化Bean，装配好Bean之间的依赖关系，为上层提供准备就绪的环境，Spring提供一个配置文件描述Bean还有Bean之间的依赖关系，利用Java语言的反射功能实例化Bean并建立Bean之间的依赖关系。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web开发" scheme="https://zouchanglin.cn/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaEE" scheme="https://zouchanglin.cn/tags/JavaEE/"/>
    
      <category term="SpringCore" scheme="https://zouchanglin.cn/tags/SpringCore/"/>
    
  </entry>
  
  <entry>
    <title>如何理解SpringIOC</title>
    <link href="https://zouchanglin.cn/2020/04/05/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3SpringIOC/"/>
    <id>https://zouchanglin.cn/2020/04/05/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3SpringIOC/</id>
    <published>2020-04-05T06:00:00.000Z</published>
    <updated>2020-04-14T03:02:25.225Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200405/IHCyMIrsdTrx.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;SpringIOC是Spring Core最核心的部分，要了解控制反转(Inversion of Control)，我觉得有必要先了解软件设计的一个重要思想：依赖倒置原则。 &lt;/p&gt;
&lt;p&gt;1、高层模块不应该依赖底层模块，二者都应该依赖抽象&lt;br&gt;2、抽象不应该依赖细节，细节应该依赖抽象。&lt;br&gt;3、依赖倒置的中心思想是面向接口编程。&lt;br&gt;4、依赖倒置原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础搭建的架构要稳定的多。&lt;br&gt;5、使用接口或抽象类的目的是指定好规范，而不涉及任何具体操作，展现细节的任务交给他们的实现类来完成。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web开发" scheme="https://zouchanglin.cn/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaEE" scheme="https://zouchanglin.cn/tags/JavaEE/"/>
    
      <category term="SpringCore" scheme="https://zouchanglin.cn/tags/SpringCore/"/>
    
  </entry>
  
  <entry>
    <title>JUC的四个并发工具类</title>
    <link href="https://zouchanglin.cn/2020/04/05/JUC%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>https://zouchanglin.cn/2020/04/05/JUC%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/</id>
    <published>2020-04-05T04:00:00.000Z</published>
    <updated>2020-04-14T03:05:32.002Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章主要记录了JUC的四个并发工具类，闭锁CountDownlatch、栅栏CyclicBarrier、信号量Semaphore、交换器Exchanger。CountDownlatch通常用于主线程等待其他任务线程执行完毕的场景；CyclicBarrier主要阻塞当前线程，等待其他线程（大家无论谁先跑到A点，必须要等其他线程也到达了A点，大家才能继续）。信号量Semaphore可以用来控制同时访问特定资源的线程数量（比如100个线程只能有10个线程可以获得MySQL连接）。交换器Exchanger很少用，只适用于两个线程在同步点交换数据的场景（如下图）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200404/xTzG4uGsytB7.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="并发编程" scheme="https://zouchanglin.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="异步" scheme="https://zouchanglin.cn/tags/%E5%BC%82%E6%AD%A5/"/>
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
      <category term="JUC" scheme="https://zouchanglin.cn/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>ForkJoin框架与读写锁</title>
    <link href="https://zouchanglin.cn/2020/04/04/ForkJoin%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%BB%E5%86%99%E9%94%81/"/>
    <id>https://zouchanglin.cn/2020/04/04/ForkJoin%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%BB%E5%86%99%E9%94%81/</id>
    <published>2020-04-04T04:00:00.000Z</published>
    <updated>2020-04-14T03:05:45.788Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Fork/Join框架就是在必要的情况下，将一个大任务，进行拆分（fork）成若千个小任务（拆到不可再拆时），再将一个个的小任务运算的结果进行join汇总。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200404/ChkDGz2ekXrP.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;ForkJoin框架采用&lt;code&gt;工作窃取&lt;/code&gt;模式(work-stealing) :当执行新的任务时它可以将其拆分分成更小的任务执行，并将小任务加到线程队列中，然后再从一个随机线程的队列中偷一个并把它放在自己的队列中。&lt;/p&gt;
&lt;p&gt;相对于一般的线程池实现，fork/join框架的优势体现在对其中包含的任务的处理方式上，在一般的线程池中，如果一个线程正在执行的任务由于某些原因无法继续运行，那么该线程会处于等待状态。而在fork/join框架实现中，如果某个子问题由于等待另外一个子问题的完成而无法继续运行。那么处理该子问题的线程会主动寻找其他尚未运行的子问题来执行。这种方式减少了线程的等待时间，提高了性能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="并发编程" scheme="https://zouchanglin.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
      <category term="JUC" scheme="https://zouchanglin.cn/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>向新冠肺炎疫情牺牲烈士和逝世同胞深切哀悼</title>
    <link href="https://zouchanglin.cn/2020/04/04/%E5%90%91%E6%96%B0%E5%86%A0%E8%82%BA%E7%82%8E%E7%96%AB%E6%83%85%E7%89%BA%E7%89%B2%E7%83%88%E5%A3%AB%E5%92%8C%E9%80%9D%E4%B8%96%E5%90%8C%E8%83%9E%E6%B7%B1%E5%88%87%E5%93%80%E6%82%BC/"/>
    <id>https://zouchanglin.cn/2020/04/04/%E5%90%91%E6%96%B0%E5%86%A0%E8%82%BA%E7%82%8E%E7%96%AB%E6%83%85%E7%89%BA%E7%89%B2%E7%83%88%E5%A3%AB%E5%92%8C%E9%80%9D%E4%B8%96%E5%90%8C%E8%83%9E%E6%B7%B1%E5%88%87%E5%93%80%E6%82%BC/</id>
    <published>2020-04-04T02:00:00.000Z</published>
    <updated>2020-04-04T02:30:11.663Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200404/mGnvkmEckwD7.png&quot;
        
      
    
    </summary>
    
    
      <category term="生活" scheme="https://zouchanglin.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>虚假唤醒与Condition控制线程通信</title>
    <link href="https://zouchanglin.cn/2020/04/03/%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92%E4%B8%8ECondition%E6%8E%A7%E5%88%B6%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    <id>https://zouchanglin.cn/2020/04/03/%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92%E4%B8%8ECondition%E6%8E%A7%E5%88%B6%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/</id>
    <published>2020-04-03T03:01:35.000Z</published>
    <updated>2020-04-14T03:06:46.071Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200403/UurprEGkmsPn.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文通过生产者消费者模型主要讲述了什么是虚假唤醒，以及处理处理虚假唤醒。另外还使用了Condition 来控制线程间的通信，Condition接口描述了可能会与锁有关联的条件变量，这些变量在用法上与使用Object.wait 访问的隐式监视器类似，但提供了更强大的功能。需要特别指出的是，单个Lock 可能与多个Condition 对象关联。为了避免兼容性问题，Condition 方法的名称与对应的Object 版本中的不同。 在Condition 对象中，与wait、notify 和notifyAll 方法对应的分别是await、signal 和signalAll。 Condition允许发生虚假唤醒，这通常作为对基础平台语义的让步。不过Condition还是应该总是在一个循环中被等待，避免虚假唤醒的发生。&lt;/p&gt;
    
    </summary>
    
    
      <category term="并发编程" scheme="https://zouchanglin.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
      <category term="JUC" scheme="https://zouchanglin.cn/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>谈谈Java的线程池</title>
    <link href="https://zouchanglin.cn/2020/04/02/%E8%B0%88%E8%B0%88Java%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://zouchanglin.cn/2020/04/02/%E8%B0%88%E8%B0%88Java%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2020-04-02T09:01:35.000Z</published>
    <updated>2020-04-14T03:07:11.575Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200402/1RKDW9iG8m8Y.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文主要讲述了使用线程池的好处，Executors创建的五种线程池特点，简单介绍了Fork/Join框架。围绕Executor框架展开，阐述了线程池的工作流程，探讨了ThreadPoolExecutor的全部构造参数和意义，以及阿里巴巴不推荐使用Executors创建线程池的原因，另外，介绍了我们应该怎么样合理的创建线程池，对于CPU密集型和IO密集型以及混合型的创建方式。探讨了新任务提交后的执行流程，另外简单画了一下线程池生命周期图。&lt;/p&gt;
&lt;p&gt;Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或者并发执行任务的程序都可以使用线程池。开发&lt;br&gt;中使用线程池的三个优点如下：&lt;br&gt;1、降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁带来的消耗。&lt;br&gt;2、提高响应速度：当任务到达时，任务可以不需要等待线程创建就能立即执行。&lt;br&gt;3、提高线程的可管理性：使用线程池可以统一进行线程分配、调度和监控。&lt;/p&gt;
    
    </summary>
    
    
      <category term="并发编程" scheme="https://zouchanglin.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
      <category term="线程池" scheme="https://zouchanglin.cn/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>CAS操作与ABA问题</title>
    <link href="https://zouchanglin.cn/2020/04/02/CAS%E6%93%8D%E4%BD%9C%E4%B8%8EABA%E9%97%AE%E9%A2%98/"/>
    <id>https://zouchanglin.cn/2020/04/02/CAS%E6%93%8D%E4%BD%9C%E4%B8%8EABA%E9%97%AE%E9%A2%98/</id>
    <published>2020-04-02T06:01:35.000Z</published>
    <updated>2020-04-14T03:07:22.701Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;我们在使用锁时，线程获取锁是一种悲观锁策略，即假设每一次执行临界区代码都会产生冲突， 所以当前线程获取到锁的时候同时也会阻塞其他线程获取该锁。而CAS操作(又称为无锁操作)是一种乐观锁策略，它假设所有线程访问共享资源的时候不会出现冲突，既然不会出现冲突自然而然就不会阻塞其他线程的操作。因此，线程就不会出现阻塞停顿的状态。那么，如果出现冲突了怎么办？无锁操作是使用CAS(compare and swap)又叫做比较交换来鉴别线程是否出现冲突，出现冲突就重试当前操作直到没有冲突为止。&lt;/p&gt;
    
    </summary>
    
    
      <category term="并发编程" scheme="https://zouchanglin.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
      <category term="JUC" scheme="https://zouchanglin.cn/tags/JUC/"/>
    
  </entry>
  
</feed>
