<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tim&#39;s Blog</title>
  
  <subtitle>当你凝望深渊时，深渊也在凝望你</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zouchanglin.cn/"/>
  <updated>2020-03-01T15:03:13.556Z</updated>
  <id>https://zouchanglin.cn/</id>
  
  <author>
    <name>changlin zou</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>图解epoll原理</title>
    <link href="https://zouchanglin.cn/2020/03/01/%E5%9B%BE%E8%A7%A3epoll%E5%8E%9F%E7%90%86/"/>
    <id>https://zouchanglin.cn/2020/03/01/%E5%9B%BE%E8%A7%A3epoll%E5%8E%9F%E7%90%86/</id>
    <published>2020-03-01T12:01:35.000Z</published>
    <updated>2020-03-01T15:03:13.556Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200301/wtDoDUaxYAlG.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;poll翻译过来是轮询的意思， 可以看到poll和epoll都有轮询的过程， 不同点在于：poll轮询的是所有的socket，而epoll只轮询就绪的socket。 epoll是开发linux高性能服务器的必备技术至，epoll本质，是服务端程序员的必须掌握的知识。 本文主要是利用图文讲述了select的原理和epoll相对于做出的优化，以及epoll的部分细节问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="高性能网络" scheme="https://zouchanglin.cn/categories/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Linux" scheme="https://zouchanglin.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>通俗理解五种IO模型</title>
    <link href="https://zouchanglin.cn/2020/02/29/%E9%80%9A%E4%BF%97%E7%90%86%E8%A7%A3%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/"/>
    <id>https://zouchanglin.cn/2020/02/29/%E9%80%9A%E4%BF%97%E7%90%86%E8%A7%A3%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-02-29T12:01:35.000Z</published>
    <updated>2020-02-29T12:24:47.279Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200229/JzUvCzR8JTH3.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;任何IO过程中，都包含两个步骤：第一是等待，第二是拷贝。而且在实际的应用场景中，等待消耗的时间往往都远远高于拷贝的时间。让IO更高效，最核心的办法就是让等待的时间尽量少。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="高性能网络" scheme="https://zouchanglin.cn/categories/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Linux" scheme="https://zouchanglin.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>select、poll和epoll多路复用</title>
    <link href="https://zouchanglin.cn/2020/02/29/select%E3%80%81poll%E5%92%8Cepoll%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    <id>https://zouchanglin.cn/2020/02/29/select%E3%80%81poll%E5%92%8Cepoll%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</id>
    <published>2020-02-29T12:01:35.000Z</published>
    <updated>2020-03-01T08:34:50.239Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200301/EQNj1T6uKbOU.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;Nginx和Redis中都用到了epoll多路复用模型，本节将讲述常见的多路复用模型：select、poll和epoll，以及部分示例代码，还是先回顾IO的两个重要过程：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;任何IO过程中，都包含两个步骤：第一是等待，第二是拷贝。而且在实际的应用场景中，等待消耗的时间往往都远远高于拷贝的时间。让IO更高效，最核心的办法就是让等待的时间尽量少。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在以前的文章中介绍了五种IO模型，分别是阻塞式IO、非阻塞式IO、信号驱动IO、多路复用IO、异步IO；前四种都属于同步IO。今天重点介绍的是多路复用IO，多路复用IO通俗讲就是一次等待多个文件描述符，减少了等待时间，提高了IO过程的效率（此IO过程并不是只是从内核态到用户态数据的拷贝，而是从发起IO请求直到IO完成的过程），接下来将介绍Linux的三种多路复用模型。&lt;/p&gt;
    
    </summary>
    
    
      <category term="高性能网络" scheme="https://zouchanglin.cn/categories/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Linux" scheme="https://zouchanglin.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Redis的数据类型</title>
    <link href="https://zouchanglin.cn/2020/02/28/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://zouchanglin.cn/2020/02/28/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-02-28T12:01:35.000Z</published>
    <updated>2020-02-28T14:38:14.027Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;今天主要介绍的是Redis的数据类型，顺便说说Redis的ping-pong：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200228/SRyi77FjHYPF.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://zouchanglin.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Redis" scheme="https://zouchanglin.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB秒级快照原理与当前读</title>
    <link href="https://zouchanglin.cn/2020/02/27/InnoDB%E7%A7%92%E7%BA%A7%E5%BF%AB%E7%85%A7%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BD%93%E5%89%8D%E8%AF%BB/"/>
    <id>https://zouchanglin.cn/2020/02/27/InnoDB%E7%A7%92%E7%BA%A7%E5%BF%AB%E7%85%A7%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BD%93%E5%89%8D%E8%AF%BB/</id>
    <published>2020-02-27T12:01:35.000Z</published>
    <updated>2020-02-27T09:33:42.040Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200227/9xbkj74TxjVu.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;在之前为文章&lt;a href=&quot;https://zouchanglin.cn/2020/02/26/分析事务隔离的实现&quot;&gt;《分析事务隔离的实现》&lt;/a&gt;中我们提到：如果是可重复读隔离级别，事务T启动的时候会创建一个视图 read-view，之后事务 T 执行期间，即使有其他事务修改了数据，事务 T 看到的仍然跟在启动时看到的一样。也就是说，一个在可重复读隔离级别下执行的事务，好像与世无争，不受外界影响。但是，我在介绍MySQL锁机制的文章中&lt;a href=&quot;https://zouchanglin.cn/2019/10/25/探究MySQL锁机制&quot;&gt;《探究MySQL锁机制》&lt;/a&gt; 的时候，一个事务要更新一行，如果刚好有另外一个事务拥有这一行的行锁，它会被锁住，进入等待状态。问题是，既然进入了等待状态，那么等到这个事务自己获取到行锁要更新数据的时候，它读到的值又是什么呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://zouchanglin.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://zouchanglin.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>分析事务隔离的实现</title>
    <link href="https://zouchanglin.cn/2020/02/27/%E5%88%86%E6%9E%90%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://zouchanglin.cn/2020/02/27/%E5%88%86%E6%9E%90%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-02-27T00:01:35.000Z</published>
    <updated>2020-02-27T09:41:45.016Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200227/a3pBOiztLcnN.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;关于MySQL的锁机制问题，在之前的博客中有谈到&lt;a href=&quot;https://zouchanglin.cn/2019/10/25/探究MySQL锁机制&quot;&gt;《探究MySQL锁机制》&lt;/a&gt; ，里面对锁的讲解比较详细，现在是在原来的基础上谈谈数据库事务相关的问题。简单来说事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在MySQL中，事务支持是在引擎层实现的。你现在知道，MySQL是一个支持多引擎的系统，但并不是所有的引|擎都支持事务。比如MySQL原生的MyISAM引擎就不支持事务，这也是MyISAM被InnoDB取代的重要原因之一。首先要知道的是数据库事务四大特性：ACID&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://zouchanglin.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://zouchanglin.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>密集索引和稀疏索引</title>
    <link href="https://zouchanglin.cn/2020/02/26/%E5%AF%86%E9%9B%86%E7%B4%A2%E5%BC%95%E5%92%8C%E7%A8%80%E7%96%8F%E7%B4%A2%E5%BC%95/"/>
    <id>https://zouchanglin.cn/2020/02/26/%E5%AF%86%E9%9B%86%E7%B4%A2%E5%BC%95%E5%92%8C%E7%A8%80%E7%96%8F%E7%B4%A2%E5%BC%95/</id>
    <published>2020-02-26T12:01:35.000Z</published>
    <updated>2020-02-27T09:37:13.115Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;密集索引：文件中的每个搜索码值都对应一个索引值，就是叶子节点保存了整行，比如InnoDB&lt;/p&gt;
&lt;p&gt;稀疏索引：文件只为索引码的某些值建立索引项，比如MyISAM&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200226/L4dIVF9GX4Si.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;密集索引的表数据按顺序存储，即索引顺序和表记录物理存储顺序一致，所以一个表只能创建一个密集索引&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://zouchanglin.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="索引" scheme="https://zouchanglin.cn/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="MySQL" scheme="https://zouchanglin.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>BTree与B+Tree</title>
    <link href="https://zouchanglin.cn/2020/02/26/BTree%E4%B8%8EB+Tree/"/>
    <id>https://zouchanglin.cn/2020/02/26/BTree%E4%B8%8EB+Tree/</id>
    <published>2020-02-26T11:01:35.000Z</published>
    <updated>2020-02-27T09:37:19.929Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;其实在之前的文章说说到过MySQL索引，只不过没细说，&lt;a href=&quot;https://zouchanglin.cn/2019/09/12/JOIN查询与索引简介/#5、MySQL索引结构&quot;&gt;《JOIN查询与索引简介》&lt;/a&gt; ，现在来看看回顾一下索引相关的数据结构，首先看看索引的定义： 索引(Index)是帮助MySQL高效获取数据的数据结构。 我不会索引就是类似于字典这样的话泛泛而谈，而是如何真正去理解索引。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://zouchanglin.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="索引" scheme="https://zouchanglin.cn/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="MySQL" scheme="https://zouchanglin.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS协议实现原理</title>
    <link href="https://zouchanglin.cn/2020/02/25/HTTPS%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://zouchanglin.cn/2020/02/25/HTTPS%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2020-02-25T11:01:35.000Z</published>
    <updated>2020-02-27T09:37:33.784Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200225/meVCCACO399R.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;HTTP协议的信息传输完全以明文方式，不做任何加密，相当于是在网络上”裸奔”。意思就是如果我们以HTTP来传输数据的话由于是明文数据，则很容易发生不安全事故，比如我登陆一个网站，那么如果是HTTP明文传输肯定就会直接把用户名和密码放在明文中，这样是非常不安全的，处在同一个局域网下的小伙伴直接抓包就可以获取你的用户名和密码，那么应该怎么办呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://zouchanglin.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://zouchanglin.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="网络安全" scheme="https://zouchanglin.cn/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
      <category term="非对称加密" scheme="https://zouchanglin.cn/tags/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>TCP的高性能机制</title>
    <link href="https://zouchanglin.cn/2020/02/25/TCP%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%9C%BA%E5%88%B6/"/>
    <id>https://zouchanglin.cn/2020/02/25/TCP%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%9C%BA%E5%88%B6/</id>
    <published>2020-02-25T04:01:35.000Z</published>
    <updated>2020-02-27T09:37:48.056Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200225/WFp4qQSRpvoo.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;之前介绍了TCP的报文格式（&lt;a href=&quot;https://zouchanglin.cn/2019/11/21/TCP协议基本特性&quot;&gt;《TCP协议基本特性》&lt;/a&gt;），TCP的连接管理，学习了TCP如何建立连接，释放连接以及一些网络安装方面的问题，现在还剩下TCP的几个关键机制，主要是TPC的延迟应答和捎带应答、超时重传、快重传和快恢复、滑动窗口机制、拥塞避免算法；然后最后还记录了TCP的粘包问题和解决方案！&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://zouchanglin.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://zouchanglin.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>谈谈HTTP协议</title>
    <link href="https://zouchanglin.cn/2020/02/25/%E8%B0%88%E8%B0%88HTTP%E5%8D%8F%E8%AE%AE/"/>
    <id>https://zouchanglin.cn/2020/02/25/%E8%B0%88%E8%B0%88HTTP%E5%8D%8F%E8%AE%AE/</id>
    <published>2020-02-25T04:01:35.000Z</published>
    <updated>2020-02-27T09:37:41.548Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;HTTP的全称 HyperText Transfer Protocol，即超文本传输协议，程序员自己发明的协议之一，基于TCP的应用层协议。 HTTP协议是基于请求-响应的模式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200225/k8pW0raF9ync.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;HTTP是一种无状态协议，HTTP协议自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个级别，协议对于发送过的请求或响应都不做持久化处理。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200225/GqrhjlASQXoQ.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://zouchanglin.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://zouchanglin.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>构造实现简单容器</title>
    <link href="https://zouchanglin.cn/2020/02/24/%E6%9E%84%E9%80%A0%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E5%AE%B9%E5%99%A8/"/>
    <id>https://zouchanglin.cn/2020/02/24/%E6%9E%84%E9%80%A0%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E5%AE%B9%E5%99%A8/</id>
    <published>2020-02-24T14:38:52.000Z</published>
    <updated>2020-02-27T09:38:13.923Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;现在即将开始真正踏上构造自己的容器的道路。我们会基于当前的操作系统创建一个与宿主机隔离的容器环境，下面就开始吧。在开始之前我们需要先对Linux的proc文件系统做一个介绍：&lt;/p&gt;
&lt;p&gt;如果你对这些基本知识已经很熟悉了，请直接略过。Linux下的/proc文件系统是由内核提供的，它其实不是一个真正的文件系统，只包含了系统运行时的信息（比如系统内存、mount设备信息、一些硬件配置等），它只存在于内存中，而不占用外存空间。它以文件系统的形式，为访问内核数据的操作提供接口。实际上，很多系统工具都是简单地去读取这个文件系统的某个文件内容，比如lsmod，其实就是cat /proc/modules。当遍历这个目录的时候，会发现很多数字，这些都是为每个进程创建的空间，数字就是它们的PID。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200224/sVzVSYCvKI6y.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="虚拟化技术" scheme="https://zouchanglin.cn/categories/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="https://zouchanglin.cn/tags/Linux/"/>
    
      <category term="Docker" scheme="https://zouchanglin.cn/tags/Docker/"/>
    
      <category term="Golang" scheme="https://zouchanglin.cn/tags/Golang/"/>
    
      <category term="文件系统" scheme="https://zouchanglin.cn/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>动手实现AUFS文件系统</title>
    <link href="https://zouchanglin.cn/2020/02/23/%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0AUFS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>https://zouchanglin.cn/2020/02/23/%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0AUFS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-02-23T03:37:40.000Z</published>
    <updated>2020-02-27T09:38:27.994Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200223/8sHdcObI1bOG.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;在之前的文章中我们探究了Docker是如何使用AUFS文件系统的，现在我们开始动手实践一下AUFS，用简单的命令来创建一个AUFS文件系统，感受下如何使用AUFS和COW实现文件管理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="虚拟化技术" scheme="https://zouchanglin.cn/categories/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="https://zouchanglin.cn/tags/Linux/"/>
    
      <category term="Docker" scheme="https://zouchanglin.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Union File System在Docker中的应用</title>
    <link href="https://zouchanglin.cn/2020/02/22/Union%20File%20System%E5%9C%A8Docker%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>https://zouchanglin.cn/2020/02/22/Union%20File%20System%E5%9C%A8Docker%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</id>
    <published>2020-02-22T07:15:41.000Z</published>
    <updated>2020-02-27T09:38:35.225Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Union-File-System&quot;&gt;&lt;a href=&quot;#Union-File-System&quot; class=&quot;headerlink&quot; title=&quot;Union File System&quot;&gt;&lt;/a&gt;Union File System&lt;/h2&gt;&lt;p&gt;Union File System，简称UnionFS，关于联合文件系统我之前的一篇博客里也写过的&lt;a href=&quot;https://zouchanglin.cn/2019/08/03/Docker镜像与数据容器卷&quot;&gt;《Docker镜像与数据容器卷》&lt;/a&gt;，是一种为Linux、FreeBSD 和NetBSD操作系统设计的，把其他文件系统联合到一个联合挂载点的文件系统服务。它使用branch把不同文件系统的文件和目录“透明地”覆盖，形成一个单一一致的文件系统。这些branch或者是read-only的，或者是read-write的，所以当对这个虚拟后的联合文件系统进行写操作的时候，系统是真正写到了一个新的文件中。看起来这个虚拟后的联合文件系统是可以对任何文件进行操作的，但是其实它并没有改变原来的文件,这是因为unionfs用到了一个重要的资源管理技术，叫写时拷贝。&lt;/p&gt;
    
    </summary>
    
    
      <category term="虚拟化技术" scheme="https://zouchanglin.cn/categories/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="https://zouchanglin.cn/tags/Linux/"/>
    
      <category term="Docker" scheme="https://zouchanglin.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Cgroups在Docker中的应用</title>
    <link href="https://zouchanglin.cn/2020/02/22/Cgroups%E5%9C%A8Docker%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>https://zouchanglin.cn/2020/02/22/Cgroups%E5%9C%A8Docker%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</id>
    <published>2020-02-22T04:20:19.000Z</published>
    <updated>2020-02-27T09:38:42.118Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;之前几篇文章讲述了Linux的Cgroups技术，&lt;a href=&quot;https://zouchanglin.cn/2020/02/20/Linux-Cgroups的资源控制/&quot;&gt;《Linux-Cgroups的资源控制》&lt;/a&gt;，主要是通过Cgroups实现了对进程的资源限制，那么在Docker中是如何运用Cgroups的呢？我们知道Docker是通过Cgroups去做的容器的资源限制和监控，我们下面就以一个实际的容器实例来看下Docker是如何配置Cgroups的：&lt;code&gt;docker run -m 设置内存限制&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200222/U7v1jf2JBKla.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以看到Docker通过为每个容器创建Cgroup并通过Cgroup去配置的资源限制和资源监控。&lt;/strong&gt; &lt;/p&gt;
    
    </summary>
    
    
      <category term="虚拟化技术" scheme="https://zouchanglin.cn/categories/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="https://zouchanglin.cn/tags/Linux/"/>
    
      <category term="Docker" scheme="https://zouchanglin.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Apache Freemarker的一个小坑</title>
    <link href="https://zouchanglin.cn/2020/02/21/Apache-Freemarker%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9D%91/"/>
    <id>https://zouchanglin.cn/2020/02/21/Apache-Freemarker%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9D%91/</id>
    <published>2020-02-21T03:38:53.000Z</published>
    <updated>2020-02-27T09:38:50.135Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn/FjkyX6iIHmYl6IFqrwnlZUnLBFXd&quot; alt=&quot;xxx.png&quot;&gt;&lt;br&gt;前段时间用到了Apache Freemarker来做前端页面，发现一个问题，就是JavaBean的Long类型和Integer类型向模板中注入的时候，只要是注入input类型，那么大&lt;br&gt;于999的数字则不会被显示，这个问题我也问了Apache官方的论坛：&lt;a href=&quot;https://issues.apache.org/jira/browse/FREEMARKER-132&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://issues.apache.org/jira/browse/FREEMARKER-132&lt;/a&gt; ,果然是官方站点呀，反馈还是很快的，系统还自动发了邮件！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web开发" scheme="https://zouchanglin.cn/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaWeb" scheme="https://zouchanglin.cn/tags/JavaWeb/"/>
    
      <category term="模板引擎" scheme="https://zouchanglin.cn/tags/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"/>
    
      <category term="前端" scheme="https://zouchanglin.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Linux Cgroups的资源控制</title>
    <link href="https://zouchanglin.cn/2020/02/20/Linux-Cgroups%E7%9A%84%E8%B5%84%E6%BA%90%E6%8E%A7%E5%88%B6/"/>
    <id>https://zouchanglin.cn/2020/02/20/Linux-Cgroups%E7%9A%84%E8%B5%84%E6%BA%90%E6%8E%A7%E5%88%B6/</id>
    <published>2020-02-20T12:03:27.000Z</published>
    <updated>2020-02-27T09:38:57.162Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;今天主要是说说Linux的Cgroup技术，之前介绍的是构建Linux容器的namespace技术，它能够很好的帮助进程隔离出自己单独的空间，但Docker又是怎么限制每个空间的大小，保证他们不会互相争抢呢？这就要用到Linux的Cgroups技术。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200221/EHaOfXGVfWwE.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;Linux Cgroups(Control Groups) 提供了对一组进程及将来的子进程的资源的限制 ，控制和统计的能力，这些资源包括CPU，内存，存储，网络等。通过Cgroups，可以方便的限制某个进程的资源占用，并且可以实时的监控进程的监控和统计信息。&lt;/p&gt;
    
    </summary>
    
    
      <category term="虚拟化技术" scheme="https://zouchanglin.cn/categories/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="https://zouchanglin.cn/tags/Linux/"/>
    
      <category term="Docker" scheme="https://zouchanglin.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>通过Namespace实现隔离</title>
    <link href="https://zouchanglin.cn/2020/02/19/%E9%80%9A%E8%BF%87Namespace%E5%AE%9E%E7%8E%B0%E9%9A%94%E7%A6%BB/"/>
    <id>https://zouchanglin.cn/2020/02/19/%E9%80%9A%E8%BF%87Namespace%E5%AE%9E%E7%8E%B0%E9%9A%94%E7%A6%BB/</id>
    <published>2020-02-19T07:02:22.000Z</published>
    <updated>2020-02-20T06:54:10.387Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200219/96tchOUQRfiQ.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;在上次的文章&lt;a href=&quot;[https://zouchanglin.cn/2020/02/18/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%9F%BA%E7%9F%B3%E2%80%94%E2%80%94Namespace/](https://zouchanglin.cn/2020/02/18/虚拟化的基石——Namespace/)&quot;&gt;《虚拟化的基石——Namespace》&lt;/a&gt; 中主要讲述了Namespace的作用，却没有详细的拿代码举证，上次仅仅证明了UTS Namespace，剩下五个命名空间全在这篇文章了，主要是IPC Namespace、PID Namespace、Mount Namespace、User Namespace、Network Namespace的概念的理解以及使用代码证明！&lt;/p&gt;
    
    </summary>
    
    
      <category term="虚拟化技术" scheme="https://zouchanglin.cn/categories/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="https://zouchanglin.cn/tags/Linux/"/>
    
      <category term="Docker" scheme="https://zouchanglin.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>虚拟化的基石——Namespace</title>
    <link href="https://zouchanglin.cn/2020/02/18/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%9F%BA%E7%9F%B3%E2%80%94%E2%80%94Namespace/"/>
    <id>https://zouchanglin.cn/2020/02/18/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%9F%BA%E7%9F%B3%E2%80%94%E2%80%94Namespace/</id>
    <published>2020-02-18T14:44:21.000Z</published>
    <updated>2020-02-20T06:54:14.123Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;每每被人问到：“Docker技术到底是怎么实现的呢？”我只能粗粗浅浅地说：“Docker是使用Linux Kernel的Namespace 和 Cgroups实现的一种容器技术。”那么，什么是Namespace，什么是Cgroups，Docker是怎么使用它们的，容器到底是怎么一步步被创建出来的？问到这些，我就会支支吾吾地不知所以。由此可见，了解容器技术的底层技术，然后明白它们是如何工作的，尤为重要，这些才是整个容器技术的基石，掌握了这些基石才能更加容易地向上攀登。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那今天就先看看Namespace吧！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200218/07pgJ5CxHbna.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="虚拟化技术" scheme="https://zouchanglin.cn/categories/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="https://zouchanglin.cn/tags/Linux/"/>
    
      <category term="Docker" scheme="https://zouchanglin.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>构建可复用模块</title>
    <link href="https://zouchanglin.cn/2020/02/18/%E6%9E%84%E5%BB%BA%E5%8F%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E6%A8%A1%E5%9D%97/"/>
    <id>https://zouchanglin.cn/2020/02/18/%E6%9E%84%E5%BB%BA%E5%8F%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E6%A8%A1%E5%9D%97/</id>
    <published>2020-02-18T02:27:22.000Z</published>
    <updated>2020-02-20T06:53:57.117Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Golang的工程管理一直是初学者所不能很好的理解的事物，本篇主要讲述了在Golang中如何进行工程管理，如何构建可复用模块，从GitHub获取Go的包是如何操作的，以及Golang的包管理工具的基本使用，这样再进行项目开发的时候就可以模块化的管理自己的工程，首先还得从Package说起！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200218/9Uui7Swk4Vcp.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="工程构建" scheme="https://zouchanglin.cn/categories/%E5%B7%A5%E7%A8%8B%E6%9E%84%E5%BB%BA/"/>
    
    
      <category term="Golang" scheme="https://zouchanglin.cn/tags/Golang/"/>
    
  </entry>
  
</feed>
