<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tim&#39;s Blog</title>
  
  <subtitle>当你凝望深渊时，深渊也在凝望你</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zouchanglin.cn/"/>
  <updated>2020-04-07T08:42:44.567Z</updated>
  <id>https://zouchanglin.cn/</id>
  
  <author>
    <name>changlin zou</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringIOC原理与应用</title>
    <link href="https://zouchanglin.cn/2020/04/05/SpringIOC%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <id>https://zouchanglin.cn/2020/04/05/SpringIOC%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/</id>
    <published>2020-04-05T10:00:00.000Z</published>
    <updated>2020-04-07T08:42:44.567Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200405/HbNPDVawlHpU.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;ICO容器的结构如上图所示，首先要让IOC容器去读取Bean的配置信息，并在容器中生成一份相应的Bean定义注册表，根据这张注册表去实例化Bean，装配好Bean之间的依赖关系，为上层提供准备就绪的环境，Spring提供一个配置文件描述Bean还有Bean之间的依赖关系，利用Java语言的反射功能实例化Bean并建立Bean之间的依赖关系。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web开发" scheme="https://zouchanglin.cn/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaEE" scheme="https://zouchanglin.cn/tags/JavaEE/"/>
    
  </entry>
  
  <entry>
    <title>如何理解SpringIOC</title>
    <link href="https://zouchanglin.cn/2020/04/05/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3SpringIOC/"/>
    <id>https://zouchanglin.cn/2020/04/05/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3SpringIOC/</id>
    <published>2020-04-05T06:00:00.000Z</published>
    <updated>2020-04-05T05:47:42.807Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200405/IHCyMIrsdTrx.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;SpringIOC是Spring Core最核心的部分，要了解控制反转(Inversion of Control)，我觉得有必要先了解软件设计的一个重要思想：依赖倒置原则。 &lt;/p&gt;
&lt;p&gt;1、高层模块不应该依赖底层模块，二者都应该依赖抽象&lt;br&gt;2、抽象不应该依赖细节，细节应该依赖抽象。&lt;br&gt;3、依赖倒置的中心思想是面向接口编程。&lt;br&gt;4、依赖倒置原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础搭建的架构要稳定的多。&lt;br&gt;5、使用接口或抽象类的目的是指定好规范，而不涉及任何具体操作，展现细节的任务交给他们的实现类来完成。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web开发" scheme="https://zouchanglin.cn/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaEE" scheme="https://zouchanglin.cn/tags/JavaEE/"/>
    
  </entry>
  
  <entry>
    <title>JUC的四个并发工具类</title>
    <link href="https://zouchanglin.cn/2020/04/05/JUC%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>https://zouchanglin.cn/2020/04/05/JUC%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/</id>
    <published>2020-04-05T04:00:00.000Z</published>
    <updated>2020-04-04T12:27:25.842Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章主要记录了JUC的四个并发工具类，闭锁CountDownlatch、栅栏CyclicBarrier、信号量Semaphore、交换器Exchanger。CountDownlatch通常用于主线程等待其他任务线程执行完毕的场景；CyclicBarrier主要阻塞当前线程，等待其他线程（大家无论谁先跑到A点，必须要等其他线程也到达了A点，大家才能继续）。信号量Semaphore可以用来控制同时访问特定资源的线程数量（比如100个线程只能有10个线程可以获得MySQL连接）。交换器Exchanger很少用，只适用于两个线程在同步点交换数据的场景（如下图）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200404/xTzG4uGsytB7.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="并发编程" scheme="https://zouchanglin.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>ForkJoin框架与读写锁</title>
    <link href="https://zouchanglin.cn/2020/04/04/ForkJoin%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%BB%E5%86%99%E9%94%81/"/>
    <id>https://zouchanglin.cn/2020/04/04/ForkJoin%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%BB%E5%86%99%E9%94%81/</id>
    <published>2020-04-04T04:00:00.000Z</published>
    <updated>2020-04-04T04:03:44.947Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Fork/Join框架就是在必要的情况下，将一个大任务，进行拆分（fork）成若千个小任务（拆到不可再拆时），再将一个个的小任务运算的结果进行join汇总。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200404/ChkDGz2ekXrP.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;ForkJoin框架采用&lt;code&gt;工作窃取&lt;/code&gt;模式(work-stealing) :当执行新的任务时它可以将其拆分分成更小的任务执行，并将小任务加到线程队列中，然后再从一个随机线程的队列中偷一个并把它放在自己的队列中。&lt;/p&gt;
&lt;p&gt;相对于一般的线程池实现，fork/join框架的优势体现在对其中包含的任务的处理方式上，在一般的线程池中，如果一个线程正在执行的任务由于某些原因无法继续运行，那么该线程会处于等待状态。而在fork/join框架实现中，如果某个子问题由于等待另外一个子问题的完成而无法继续运行。那么处理该子问题的线程会主动寻找其他尚未运行的子问题来执行。这种方式减少了线程的等待时间，提高了性能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="并发编程" scheme="https://zouchanglin.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>向新冠肺炎疫情牺牲烈士和逝世同胞深切哀悼</title>
    <link href="https://zouchanglin.cn/2020/04/04/%E5%90%91%E6%96%B0%E5%86%A0%E8%82%BA%E7%82%8E%E7%96%AB%E6%83%85%E7%89%BA%E7%89%B2%E7%83%88%E5%A3%AB%E5%92%8C%E9%80%9D%E4%B8%96%E5%90%8C%E8%83%9E%E6%B7%B1%E5%88%87%E5%93%80%E6%82%BC/"/>
    <id>https://zouchanglin.cn/2020/04/04/%E5%90%91%E6%96%B0%E5%86%A0%E8%82%BA%E7%82%8E%E7%96%AB%E6%83%85%E7%89%BA%E7%89%B2%E7%83%88%E5%A3%AB%E5%92%8C%E9%80%9D%E4%B8%96%E5%90%8C%E8%83%9E%E6%B7%B1%E5%88%87%E5%93%80%E6%82%BC/</id>
    <published>2020-04-04T02:00:00.000Z</published>
    <updated>2020-04-04T02:30:11.663Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200404/mGnvkmEckwD7.png&quot;
        
      
    
    </summary>
    
    
      <category term="生活" scheme="https://zouchanglin.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>虚假唤醒与Condition控制线程通信</title>
    <link href="https://zouchanglin.cn/2020/04/03/%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92%E4%B8%8ECondition%E6%8E%A7%E5%88%B6%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    <id>https://zouchanglin.cn/2020/04/03/%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92%E4%B8%8ECondition%E6%8E%A7%E5%88%B6%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/</id>
    <published>2020-04-03T03:01:35.000Z</published>
    <updated>2020-04-04T03:41:43.422Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200403/UurprEGkmsPn.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文通过生产者消费者模型主要讲述了什么是虚假唤醒，以及处理处理虚假唤醒。另外还使用了Condition 来控制线程间的通信，Condition接口描述了可能会与锁有关联的条件变量，这些变量在用法上与使用Object.wait 访问的隐式监视器类似，但提供了更强大的功能。需要特别指出的是，单个Lock 可能与多个Condition 对象关联。为了避免兼容性问题，Condition 方法的名称与对应的Object 版本中的不同。 在Condition 对象中，与wait、notify 和notifyAll 方法对应的分别是await、signal 和signalAll。 Condition允许发生虚假唤醒，这通常作为对基础平台语义的让步。不过Condition还是应该总是在一个循环中被等待，避免虚假唤醒的发生。&lt;/p&gt;
    
    </summary>
    
    
      <category term="并发编程" scheme="https://zouchanglin.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>谈谈Java的线程池</title>
    <link href="https://zouchanglin.cn/2020/04/02/%E8%B0%88%E8%B0%88Java%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://zouchanglin.cn/2020/04/02/%E8%B0%88%E8%B0%88Java%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2020-04-02T09:01:35.000Z</published>
    <updated>2020-04-02T07:32:32.952Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200402/1RKDW9iG8m8Y.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文主要讲述了使用线程池的好处，Executors创建的五种线程池特点，简单介绍了Fork/Join框架。围绕Executor框架展开，阐述了线程池的工作流程，探讨了ThreadPoolExecutor的全部构造参数和意义，以及阿里巴巴不推荐使用Executors创建线程池的原因，另外，介绍了我们应该怎么样合理的创建线程池，对于CPU密集型和IO密集型以及混合型的创建方式。探讨了新任务提交后的执行流程，另外简单画了一下线程池生命周期图。&lt;/p&gt;
&lt;p&gt;Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或者并发执行任务的程序都可以使用线程池。开发&lt;br&gt;中使用线程池的三个优点如下：&lt;br&gt;1、降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁带来的消耗。&lt;br&gt;2、提高响应速度：当任务到达时，任务可以不需要等待线程创建就能立即执行。&lt;br&gt;3、提高线程的可管理性：使用线程池可以统一进行线程分配、调度和监控。&lt;/p&gt;
    
    </summary>
    
    
      <category term="并发编程" scheme="https://zouchanglin.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>CAS操作与ABA问题</title>
    <link href="https://zouchanglin.cn/2020/04/02/CAS%E6%93%8D%E4%BD%9C%E4%B8%8EABA%E9%97%AE%E9%A2%98/"/>
    <id>https://zouchanglin.cn/2020/04/02/CAS%E6%93%8D%E4%BD%9C%E4%B8%8EABA%E9%97%AE%E9%A2%98/</id>
    <published>2020-04-02T06:01:35.000Z</published>
    <updated>2020-04-02T04:06:35.482Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;我们在使用锁时，线程获取锁是一种悲观锁策略，即假设每一次执行临界区代码都会产生冲突， 所以当前线程获取到锁的时候同时也会阻塞其他线程获取该锁。而CAS操作(又称为无锁操作)是一种乐观锁策略，它假设所有线程访问共享资源的时候不会出现冲突，既然不会出现冲突自然而然就不会阻塞其他线程的操作。因此，线程就不会出现阻塞停顿的状态。那么，如果出现冲突了怎么办？无锁操作是使用CAS(compare and swap)又叫做比较交换来鉴别线程是否出现冲突，出现冲突就重试当前操作直到没有冲突为止。&lt;/p&gt;
    
    </summary>
    
    
      <category term="并发编程" scheme="https://zouchanglin.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantLock与AQS</title>
    <link href="https://zouchanglin.cn/2020/04/01/ReentrantLock%E4%B8%8EAQS/"/>
    <id>https://zouchanglin.cn/2020/04/01/ReentrantLock%E4%B8%8EAQS/</id>
    <published>2020-04-01T06:01:35.000Z</published>
    <updated>2020-04-02T14:32:11.961Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;synchronized和ReentrantLock的区别&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200402/jwuyI7Ai9jFH.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;先说说synchronized和ReentrantLock的区别吧，AQS的分析得等两天了：&lt;/p&gt;
&lt;p&gt;1、ReentrantLock (再入锁)，位于java.util.concurrent.locks包&lt;br&gt;2、和CountDownLatch、Future Task、Semaphore一样基于AQS实现&lt;br&gt;3、能够实现比synchronized更细粒度的控制，如控制公平与非公平&lt;br&gt;4、调用lock()之后，必须调用unlock()释放锁&lt;br&gt;5、性能未必比synchronized高，并且也是可重入的&lt;br&gt;6、synchronized是关键字，ReentrantLock是类&lt;br&gt;7、ReentrantLock可以对获取锁的等待时间进行设置，避免死锁的发生&lt;br&gt;8、ReentrantLock可以获取各种锁的信息&lt;br&gt;9、ReentrantLock可以灵活地实现多路通知&lt;br&gt;10、机制：sync操作Mark Word，lock调用Unsafe类的park()方法&lt;/p&gt;
    
    </summary>
    
    
      <category term="并发编程" scheme="https://zouchanglin.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>synchronized实现与优化</title>
    <link href="https://zouchanglin.cn/2020/03/31/synchronized%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
    <id>https://zouchanglin.cn/2020/03/31/synchronized%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BC%98%E5%8C%96/</id>
    <published>2020-03-31T06:01:35.000Z</published>
    <updated>2020-04-01T11:06:29.849Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;本文主要讲述了synchronized的实现原理，还有synchronized的优化。其中主要包括了自适应自旋，锁消除、锁粗化、以及偏向锁和轻量级锁。另外阐述了锁的内存语义和对三种锁的总结。其实工程学科就是不断解决实际问题才能得以发展，synchronized从早期的一上来就直接使用Mutex逐步优化到现在的程度，mutex互斥量是最重要的同步原语，但是我们去使用mutex的时候却会出现诸多问题（比如销毁了已加锁的互斥量、死锁问题）Monitor机制是编程语言在语法上提供的语法糖，假设我们用的是C语言，那么很明显无法使用Monitor机制。&lt;/p&gt;
&lt;p&gt;很多文章笼统的说synchronized是基于Monitor机制实现的，我认为这是错误的说法，Monitor 机制必须要有临界区、Monitor对象和互斥量、条件变量和wait()、signal()等要素。在synchronized的实现中根本找不到所有对应的元素。我认为Java的Monitor机制包括了synchronized、Object和程序员自己定的条件变量等（因为我们通常使用wait()、 notify()、notifyAll()配合synchronized才能取解决生产者消费者问题），这才一套完整的Monitor机制。JVM的ObjectMonitor用来辅助Java实现Monitor机制，直接把JVM的ObjectMonitor当成Monitor机制是不可取的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="并发编程" scheme="https://zouchanglin.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>synchronized锁的是什么</title>
    <link href="https://zouchanglin.cn/2020/03/28/synchronized%E9%94%81%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>https://zouchanglin.cn/2020/03/28/synchronized%E9%94%81%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88/</id>
    <published>2020-03-28T06:01:35.000Z</published>
    <updated>2020-03-28T11:07:04.665Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;最近发现synchronized锁的是什么？甚至有人认为synchronized锁的是代码？？！这个我觉得还是很有必要通过实际的示例来说明synchronized锁的到底是什么。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;根据获取的锁的分类：获取对象锁和获取类锁！&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;获取对象锁的两种用法&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、同步代码块(synchronized(this), synchronized(类实例对象))，锁是小括号()中的实例对象。&lt;br&gt;2、同步非静态方法(synchronized method)，锁是当前对象的实例对象。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;获取类锁的两种用法&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、同步代码块(synchronized(类.class))，锁是小括号()中的类对象，即Class对象。&lt;br&gt;2、同步静态方法(synchronized static method)，锁是当前对象的类对象(Class对象)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="并发编程" scheme="https://zouchanglin.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>线程相关的基础问题</title>
    <link href="https://zouchanglin.cn/2020/03/23/%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98/"/>
    <id>https://zouchanglin.cn/2020/03/23/%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98/</id>
    <published>2020-03-23T06:01:35.000Z</published>
    <updated>2020-03-25T05:15:21.742Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200324/n0eEP9zdhKzQ.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文主要讲述了进程和线程发展简史，对于JVM来讲的进程和线程又是什么，Thread的start()方法的原生调用发生了什么，从而理解start()方法和run()方法有什么不同，另外，还介绍了三种处理线程执行完成后的返回值的方法，其实FutureTask和线程池获取线程执行结束的返回值更加常用。另外，介绍了线程的六种状态，还有sleep和wait的区别，notify和notifyAll的区别，yield函数的作用，以及如何优雅的中断线程等问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="并发编程" scheme="https://zouchanglin.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>OkHttp的使用与跳坑示例</title>
    <link href="https://zouchanglin.cn/2020/03/22/OkHttp%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%B7%B3%E5%9D%91%E7%A4%BA%E4%BE%8B/"/>
    <id>https://zouchanglin.cn/2020/03/22/OkHttp%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%B7%B3%E5%9D%91%E7%A4%BA%E4%BE%8B/</id>
    <published>2020-03-22T06:01:35.000Z</published>
    <updated>2020-03-22T10:10:08.524Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200322/4XcsC1Ht6x4l.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;OkHttp是一个优秀的网络请求框架，我开始接触Android开发的时候就用过这个网络请求框架，官方的参考文档在这里  &lt;a href=&quot;https://square.github.io/okhttp/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://square.github.io/okhttp/&lt;/a&gt; ，本文演示了使用OkHttp框架进行简单的Get、Post（表单形式和JSON形式）、Delete、附加请求头、请求异步回调，文件的上传和下载等常用操作。最后记录了一个今天调试了很久的坑，那就是response.body().string()只能有效调用一次，注意Debug的时候对结果造成的改变！JDK9的HttpURLConnection有很多变化，下次博客中会有演示和说明。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web开发" scheme="https://zouchanglin.cn/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaWeb" scheme="https://zouchanglin.cn/tags/JavaWeb/"/>
    
      <category term="异步" scheme="https://zouchanglin.cn/tags/%E5%BC%82%E6%AD%A5/"/>
    
      <category term="上传下载" scheme="https://zouchanglin.cn/tags/%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>Docker私服配置HTTPS</title>
    <link href="https://zouchanglin.cn/2020/03/21/Docker%E7%A7%81%E6%9C%8D%E9%85%8D%E7%BD%AEHTTPS/"/>
    <id>https://zouchanglin.cn/2020/03/21/Docker%E7%A7%81%E6%9C%8D%E9%85%8D%E7%BD%AEHTTPS/</id>
    <published>2020-03-21T06:01:35.000Z</published>
    <updated>2020-03-21T12:45:25.313Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200321/vL5w2LvCRPhV.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图即使我搭建完毕的效果。对于Docker的环境安装，基础命令之类的内容，通读官网文档内容基本都能顺利掌握。 然而，当笔者尝试着搭建一套基于SSL的Docker Registry（官网推荐的做法）却遇到了不少的麻烦，对于这部分内容，大多数博客文档内容都是直接跳过了SSL的环节，采用了HTTP的访问形式。 然而本文就是记录一下对于搭建HTTPS 访问形式的Docker Registry的过程，读者很容易复现的过程！&lt;/p&gt;
&lt;p&gt;我的环境是CentOS7_x64，Docker版本是 Client: Docker Engine - Community 19.03.7、Server: Docker Engine - Community 19.03.7、Nginx源码包的版本是nginx-1.9.9.tar.gz。&lt;/p&gt;
    
    </summary>
    
    
      <category term="虚拟化技术" scheme="https://zouchanglin.cn/categories/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Docker" scheme="https://zouchanglin.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>优雅的实现单例</title>
    <link href="https://zouchanglin.cn/2020/03/18/%E4%BC%98%E9%9B%85%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B/"/>
    <id>https://zouchanglin.cn/2020/03/18/%E4%BC%98%E9%9B%85%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B/</id>
    <published>2020-03-18T06:01:35.000Z</published>
    <updated>2020-03-18T15:52:17.775Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;单例模式属于创建型设计模式，一个类在虚拟机中只有一份实例。实现单例模式的核心思想在于构造函数私有化，主要实现方式分为两种：懒汉式和饿汉式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200318/uUtN2uPGYzCk.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://zouchanglin.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
      <category term="JVM" scheme="https://zouchanglin.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java的四种引用</title>
    <link href="https://zouchanglin.cn/2020/03/15/Java%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8/"/>
    <id>https://zouchanglin.cn/2020/03/15/Java%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8/</id>
    <published>2020-03-15T06:01:35.000Z</published>
    <updated>2020-03-17T12:25:06.404Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200316/mALYmfXLzFOP.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;在Java语言中，除了原始数据类型的变量，其他所有都是所谓的引用类型，指向各种不同的对象，理解引用对于掌握Java对象生命周期和JVM内部相关机制非常有帮助。本文讲述了强引用、软引用、弱引用、幻象引用的区别以及一些具体使用场景，而且是配合ReferenceQueue使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="https://zouchanglin.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
      <category term="JVM" scheme="https://zouchanglin.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>请丢弃finalize</title>
    <link href="https://zouchanglin.cn/2020/03/15/%E8%AF%B7%E4%B8%A2%E5%BC%83finalize/"/>
    <id>https://zouchanglin.cn/2020/03/15/%E8%AF%B7%E4%B8%A2%E5%BC%83finalize/</id>
    <published>2020-03-14T23:01:35.000Z</published>
    <updated>2020-03-17T04:39:38.664Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;用过JDK9的同学应该发现了，finalize方法在JDK9中已经被标记为deprecated，今天探讨一下finalize方法。如果没有特别的原因，不要实现finalize方法，也不要指望利用它来进行资源回收。因为你无法保证finalize什么时候执行，执行的是否符合预期。使用不当会影响性能，导致程序死锁、挂起等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="https://zouchanglin.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
      <category term="JVM" scheme="https://zouchanglin.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>9种垃圾收集器</title>
    <link href="https://zouchanglin.cn/2020/03/12/9%E7%A7%8D%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>https://zouchanglin.cn/2020/03/12/9%E7%A7%8D%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</id>
    <published>2020-03-11T23:01:35.000Z</published>
    <updated>2020-03-13T03:06:29.627Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200312/5dC8XXcmBoUn.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;目前的垃圾收集器主要有7种，上图是他们的使用关系，连在一起的就可以配合使用。JDK11出现两种新的垃圾收集器，一个是Epsilon垃圾收集器，一个是ZGC垃圾收集器。垃圾收集器中很重要的两个概念：Stop-The-World和Safepoint。首先说说Stop-The-World：JVM由于要执行GC而停止了应用程序的执行，任何一种GC算法中都会发生。多数GC优化通过减少Stop-the -world发生的时间来提高程序性能。安全点 Safepoint：分析过程中对象引用关系不会发生变化的点，产生Safepoint的地方：方法调用、循环跳转、异常跳转等，安全点数量得适中。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="https://zouchanglin.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
      <category term="JVM" scheme="https://zouchanglin.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>垃圾标记与收集算法</title>
    <link href="https://zouchanglin.cn/2020/03/11/%E5%9E%83%E5%9C%BE%E6%A0%87%E8%AE%B0%E4%B8%8E%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/"/>
    <id>https://zouchanglin.cn/2020/03/11/%E5%9E%83%E5%9C%BE%E6%A0%87%E8%AE%B0%E4%B8%8E%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/</id>
    <published>2020-03-10T23:01:35.000Z</published>
    <updated>2020-03-13T03:06:29.731Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;本文主要是以通俗易懂的画图方式解释了标记清除算法和可达性分析算法，以及常用的回收算法（标记清除、标记整理、复制算法）以及整合百家之长的分代回收算法，另外还介绍了触发Full GC的几个场景。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="https://zouchanglin.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
      <category term="JVM" scheme="https://zouchanglin.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型的回顾</title>
    <link href="https://zouchanglin.cn/2020/03/10/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%9B%9E%E9%A1%BE/"/>
    <id>https://zouchanglin.cn/2020/03/10/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%9B%9E%E9%A1%BE/</id>
    <published>2020-03-09T23:01:35.000Z</published>
    <updated>2020-03-13T03:06:29.664Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200310/6jem5nNs1Jug.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;本篇文章主要讲述了Java内存模型中的程序计数器、虚拟机栈、本地方法栈、元空间与堆，以及堆中的常量池。前面通过javap反编译class文件得到&lt;code&gt;int add(int a, int b)&lt;/code&gt;函数的栈帧，主要分析了栈帧中JVM指令对应的局部变量表、操作数栈、程序计数器的状态变化。以及JDK7以后出现了替代永久代的元数据区，并分析了元数据区替换了永久代有哪些好处，主要分析了给字符串常量池带来的影响，并通过代码验证了元数据区相比永久代的优越性。学习了JVM性能调优的三个参数的意义和普通用法，最后探讨了并验证了JDK1.6与JDK1.7+的版本String类的intern方法的不同表现结果，分析了出现不同结果的原因，其实主要是JDK1.6的版本是建立副本再放入字符串常量池，而JDK1.7+版本时直接把堆上的对象的引用入池。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="https://zouchanglin.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
      <category term="JVM" scheme="https://zouchanglin.cn/tags/JVM/"/>
    
      <category term="字符串" scheme="https://zouchanglin.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
</feed>
