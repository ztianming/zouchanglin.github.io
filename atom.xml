<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tim&#39;s Blog</title>
  
  <subtitle>加油，冲冲冲...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zouchanglin.cn/"/>
  <updated>2020-04-28T04:37:59.087Z</updated>
  <id>https://zouchanglin.cn/</id>
  
  <author>
    <name>邹长林</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring如何解决循环依赖</title>
    <link href="https://zouchanglin.cn/2020/04/28/Spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
    <id>https://zouchanglin.cn/2020/04/28/Spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</id>
    <published>2020-04-28T00:25:00.000Z</published>
    <updated>2020-04-28T04:37:59.087Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Spring如何解决循环依赖是经常会被面试官问到的一个问题，这个问题算是关于Spring的一个高频面试题，因为如果不刻意研读，相信即使读过源码，面试者也不一定能够一下子思考出其中的原理。本文主要针对这个问题，从源码的角度对其实现原理进行讲解，彻底搞懂Spring究竟是如何解决循环依赖的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web开发" scheme="https://zouchanglin.cn/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaEE" scheme="https://zouchanglin.cn/tags/JavaEE/"/>
    
      <category term="SpringCore" scheme="https://zouchanglin.cn/tags/SpringCore/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot启动流程探究</title>
    <link href="https://zouchanglin.cn/2020/04/25/SpringBoot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%8E%A2%E7%A9%B6/"/>
    <id>https://zouchanglin.cn/2020/04/25/SpringBoot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%8E%A2%E7%A9%B6/</id>
    <published>2020-04-25T10:00:00.000Z</published>
    <updated>2020-04-25T11:04:18.362Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Spring的丰富生态备受开发者青睐，尤其是自从SpringBoot出现之后去掉了原来的复杂配置，因为SpringBoot的理念就是&lt;code&gt;约定大于配置&lt;/code&gt;，这让我们省去了很多需要手动配置的过程，就拿SpringMVC来说吧各种XML配置直接劝退初学者，但是SpringBoot的易用性简直是成为了推广Spring生态的利器。本篇文章主要是结合SpringBoot的源码，来探究SpringBoot应用程序的启动流程！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web开发" scheme="https://zouchanglin.cn/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaEE" scheme="https://zouchanglin.cn/tags/JavaEE/"/>
    
      <category term="SpringBoot" scheme="https://zouchanglin.cn/tags/SpringBoot/"/>
    
      <category term="SpringCore" scheme="https://zouchanglin.cn/tags/SpringCore/"/>
    
  </entry>
  
  <entry>
    <title>索引堆的实现与优化</title>
    <link href="https://zouchanglin.cn/2020/04/24/%E7%B4%A2%E5%BC%95%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
    <id>https://zouchanglin.cn/2020/04/24/%E7%B4%A2%E5%BC%95%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BC%98%E5%8C%96/</id>
    <published>2020-04-24T10:00:00.000Z</published>
    <updated>2020-04-25T10:52:36.021Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在之前文章中记述了堆的实现（插入方式建堆、heapify方式建堆以及堆排序）&lt;a href=&quot;https://zouchanglin.cn/2020/04/13/堆的实现及其应用&quot;&gt;《 堆的实现及其应用 》&lt;/a&gt;。今天来看看索引堆是个什么东西，对于我们所关心的这个数组而言，数组中的元素位置发生了改变。正是因为这些元素的位置发生了改变，我们才能将其构建为最大堆。 如果元素十分复杂的话，比如像每个位置上存的是一篇上万字的文章。那么交换它们之间的位置将产生大量的时间消耗。并且由于数组元素的位置在构建成堆之后发生了改变，那么我们就很难索引到它，很难去改变它。可以在每一个元素上再加上一个属性来表示原来的位置可以解决，但是这样的话，必须将这个数组遍历一下才能解决。针对以上问题，我们就需要引入索引堆（Index Heap）的概念。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://zouchanglin.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="堆" scheme="https://zouchanglin.cn/tags/%E5%A0%86/"/>
    
      <category term="二叉树" scheme="https://zouchanglin.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>什么是可中断锁</title>
    <link href="https://zouchanglin.cn/2020/04/23/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E4%B8%AD%E6%96%AD%E9%94%81/"/>
    <id>https://zouchanglin.cn/2020/04/23/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E4%B8%AD%E6%96%AD%E9%94%81/</id>
    <published>2020-04-23T10:00:00.000Z</published>
    <updated>2020-04-23T11:48:46.816Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Lock是可中断锁，而synchronized不是可中断锁。现假设线程A和B都要获取对象O的锁定，假设A获取了对象O锁，B将等待A释放对O的锁定，如果使用synchronized，如果A不释放，B将一直等下去，不能被中断；如果使用ReentrantLock，如果A不释放，可以使B在等待了足够长的时间以后，中断等待，而干别的事情。获取锁超时机制还是属于不可中断，属于超时被动放弃去竞争锁，而lockInterruptibly是可主动放弃竞争锁行为的一种方式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="并发编程" scheme="https://zouchanglin.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>JDK11新特性</title>
    <link href="https://zouchanglin.cn/2020/04/17/JDK11%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://zouchanglin.cn/2020/04/17/JDK11%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2020-04-17T10:00:00.000Z</published>
    <updated>2020-04-20T06:14:53.785Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Oracle官方于2018年9月26日宣布Java11正式发布。目前Oracle 官方也已经宣布Java11正式可以商用，这是Java 大版本周期变化后的第一个长期支持版本，非常值得关注。最新发布的Java11一共包含17个JEP（JDK Enhancement Proposals，JDK 增强提案）。对于企业来说，选择Java11将意味着长期的、可靠的、可预测的技术路线图。其中免费的OpenJDK11确定将得到OpenJDK社区的长期支持，LTS版本将是可以放心选择的版本。由于JDK9和JDK10都是一个过渡版本，JDK11的特性是在JDK9中就有的，我在博客里也做了总结&lt;a href=&quot;https://zouchanglin.cn/2020/04/15/JDK9新特性(一)&quot;&gt;《 JDK9新特性(一)》&lt;/a&gt;， &lt;a href=&quot;https://zouchanglin.cn/2020/04/16/JDK9新特性(二)&quot;&gt;《JDK9新特性(二)》&lt;/a&gt; ，其中已经介绍过的新特性将不会在这篇文章出现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="https://zouchanglin.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
      <category term="GC" scheme="https://zouchanglin.cn/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>JDK9新特性(二)</title>
    <link href="https://zouchanglin.cn/2020/04/16/JDK9%E6%96%B0%E7%89%B9%E6%80%A7(%E4%BA%8C)/"/>
    <id>https://zouchanglin.cn/2020/04/16/JDK9%E6%96%B0%E7%89%B9%E6%80%A7(%E4%BA%8C)/</id>
    <published>2020-04-16T10:00:00.000Z</published>
    <updated>2020-04-19T12:09:02.919Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇的文章我记述了JDK9的两个最重要的特性：一个是模块化，一个是jShell。另外就是String底层存储结构和StreamAPI的一些改动与优化。本次要记述主要的特性是全新的多分辨率图像API、全新的HTTP客户端API（其实是借鉴OkHTTP的框架，或者说是整合吧）、Deprecated相关API、智能Java编译工具与动态编译器、统一的JVM日志系统、javadoc对H5的支持、JavaScript引擎升级：Nashorn。然后再谈谈JDK9还需要什么吧，也就是对未来Java的展望。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="https://zouchanglin.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
      <category term="模块化" scheme="https://zouchanglin.cn/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
      <category term="交互式" scheme="https://zouchanglin.cn/tags/%E4%BA%A4%E4%BA%92%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JDK9新特性(一)</title>
    <link href="https://zouchanglin.cn/2020/04/15/JDK9%E6%96%B0%E7%89%B9%E6%80%A7(%E4%B8%80)/"/>
    <id>https://zouchanglin.cn/2020/04/15/JDK9%E6%96%B0%E7%89%B9%E6%80%A7(%E4%B8%80)/</id>
    <published>2020-04-15T10:00:00.000Z</published>
    <updated>2020-04-20T03:26:49.452Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Java8在2014年3月份推出的，而历经曲折的Java9终于终于在2017年9月21日发布，中间历经3年多时间，Java9提供了超过150项新功能特性，包括备受期待的模块化系统、可交互的 REPL 工具：jshell，JDK 编译工具，Java 公共 API 和私有代码，以及安全增强、扩展提升、性能管理改善等。可以说Java 9是一个庞大的系统工程，完全做了一个整体改变。Java8中最核心的新特性就是Lambda表达式和Stream API，那么对于Java9来说其中最核心莫过于模块化系统和JShell命令。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="https://zouchanglin.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
      <category term="模块化" scheme="https://zouchanglin.cn/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
      <category term="交互式" scheme="https://zouchanglin.cn/tags/%E4%BA%A4%E4%BA%92%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JDK8新特性</title>
    <link href="https://zouchanglin.cn/2020/04/14/JDK8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://zouchanglin.cn/2020/04/14/JDK8%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2020-04-14T10:00:00.000Z</published>
    <updated>2020-04-17T04:07:16.105Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;虽然已经用过了一些Java8的新特性，但是总来没有仔细总结一下。Java8自从2014年就发布了，到目前为止只有一小部分公司在用JDK7及其以下的版本，大部分已经迁移至Java8，甚至Java11（关于Java9和Java11的特性我会在之后两篇文章中记述），目前只看Java8那些最主要的、也是最常用的新特性，我到目前为止用到的最多的也就是Stream API和Lambda表达式，新时间日期的API也比较常用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="https://zouchanglin.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
      <category term="Stream" scheme="https://zouchanglin.cn/tags/Stream/"/>
    
      <category term="Lambda" scheme="https://zouchanglin.cn/tags/Lambda/"/>
    
  </entry>
  
  <entry>
    <title>堆的实现及其应用</title>
    <link href="https://zouchanglin.cn/2020/04/13/%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"/>
    <id>https://zouchanglin.cn/2020/04/13/%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</id>
    <published>2020-04-13T10:00:00.000Z</published>
    <updated>2020-04-24T05:05:12.894Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章记述的是堆排序，这个名字看起来好像又要介绍一个排序算法，但是排序算法是次要的，主要的是一个数据结构——堆。堆排序问题就是堆这种数据结构所衍生出来的一个应用，我们先了解一下优先队列的概念。普通的队列就是满足先进先出、后进后出的一个结构。那么优先级队列呢？出队顺序和入队顺序无关，和优先级相关，这就比如在医院看病，肯定是急诊病人优先看病。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://zouchanglin.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="https://zouchanglin.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
      <category term="堆" scheme="https://zouchanglin.cn/tags/%E5%A0%86/"/>
    
      <category term="二叉树" scheme="https://zouchanglin.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>注解的原理与实现</title>
    <link href="https://zouchanglin.cn/2020/04/12/%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>https://zouchanglin.cn/2020/04/12/%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-04-12T10:00:00.000Z</published>
    <updated>2020-04-15T06:04:25.034Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;注解这个东西自从SpringBoot以来一直是Java开发者们必备的生存技巧呀，我们平时几乎大部分时间都是面向注解编程，通过注解我们可以节约大量的时间。用过了这么多的注解，那么我们否有关注过注解的实现原理呢？所以本篇文章主要是讲述注解的有关操作，自己实现一个注解来体会注解的实现原理，注解也不是特别高深的东西，掌握了自然就明白了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="https://zouchanglin.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="JavaWeb" scheme="https://zouchanglin.cn/tags/JavaWeb/"/>
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
      <category term="JavaEE" scheme="https://zouchanglin.cn/tags/JavaEE/"/>
    
  </entry>
  
  <entry>
    <title>关于快排和归并的思考</title>
    <link href="https://zouchanglin.cn/2020/04/11/%E5%85%B3%E4%BA%8E%E5%BF%AB%E6%8E%92%E5%92%8C%E5%BD%92%E5%B9%B6%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>https://zouchanglin.cn/2020/04/11/%E5%85%B3%E4%BA%8E%E5%BF%AB%E6%8E%92%E5%92%8C%E5%BD%92%E5%B9%B6%E7%9A%84%E6%80%9D%E8%80%83/</id>
    <published>2020-04-11T10:00:00.000Z</published>
    <updated>2020-04-14T12:01:02.853Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;归并排序和快速排序是两种稍微复杂的排序算法，它们用的都是分治的思想，代码都通过递归来实现，过程非常相似。归并排序算法是一种在任何情况下时间复杂度都比较稳定的排序算法，这也使它存在致命的缺点，即归并排序不是原地排序算法，空间复杂度比较高，是 O(n)。正因为此它也没有快排应用广泛。快速排序算法虽然最坏情况下的时间复杂度是 O(n²)，但是平均情况下时间复杂度都是 O(nlogn)。且快速排序算法时间复杂度退化到 O(n²) 的概率非常小，我们可以通过合理地选择基准值来避免这种情况。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://zouchanglin.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="https://zouchanglin.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>快速排序及其优化</title>
    <link href="https://zouchanglin.cn/2020/04/10/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"/>
    <id>https://zouchanglin.cn/2020/04/10/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/</id>
    <published>2020-04-10T10:00:00.000Z</published>
    <updated>2020-04-14T10:06:23.620Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;快速排序(Quick Sort)被称为20世纪对世界影响最大的算法之一，现在我们来看快速排序算法，习惯性把它简称为快排，快排利用的也是分治思想。乍看起来，它有点像归并排序，但是思路其实完全不一样。现在，我们先来看下快排的核心思想，最后将讲述快速排序的两个优化方案，其实还有一种三路快排的优化方案也是可以的，但是本片文章重点在于快速排序的原理和实现，所以三路快排的优化方案不会出现在这篇文章里，以后再详细记录一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://zouchanglin.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="https://zouchanglin.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>O(nLogn)的归并排序</title>
    <link href="https://zouchanglin.cn/2020/04/09/O(nLogn)%E7%9A%84%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>https://zouchanglin.cn/2020/04/09/O(nLogn)%E7%9A%84%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</id>
    <published>2020-04-09T10:00:00.000Z</published>
    <updated>2020-04-12T01:13:31.777Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;之前几篇文章我介绍了三种O(n²)的排序算法&lt;a href=&quot;https://zouchanglin.cn/2020/04/07/O(n²)的三个排序算法&quot;&gt;《O(n²)的三个排序算法》&lt;/a&gt;（选择排序、插入排序和冒泡排序）以及它们的优化，然后顺便还写了一篇希尔排序的文章&lt;a href=&quot;https://zouchanglin.cn/2020/04/09/插入排序的优化之希尔排序&quot;&gt;《插入排序的优化之希尔排序》&lt;/a&gt;，但是其实用的比较多的还是直接插入排序，它们比较适合于小规模数据的排序 。下面我将记录时间复杂度为nlog(n)的几种排序算法之一 —— 归并排序算法，这种排序算法适合大规模的数据排序，比之前的O(n²)的三种排序算法更为常用，在学习之前我们可以先对比一下nlog(n)和n²是什么概念。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://zouchanglin.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="https://zouchanglin.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>插入排序的优化之希尔排序</title>
    <link href="https://zouchanglin.cn/2020/04/09/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BC%98%E5%8C%96%E4%B9%8B%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    <id>https://zouchanglin.cn/2020/04/09/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BC%98%E5%8C%96%E4%B9%8B%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</id>
    <published>2020-04-09T03:00:00.000Z</published>
    <updated>2020-04-09T04:42:28.387Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;希尔排序是插入排序的一种，又称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法，可以说它是插入排序的高级版。我们可以先回顾一下直接插入排序的过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200408/epYKaCrsQqxV.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;排序前将第一个元素看成有序的数列&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第1趟排序后：得到一个长度为2的有序数列&lt;/li&gt;
&lt;li&gt;第2趟排序后：得到一个长度为3的有序数列&lt;/li&gt;
&lt;li&gt;第3趟排序后：得到一个长度为4的有序数列&lt;/li&gt;
&lt;li&gt;……..每趟插入排序，都可以将一个无序值插入一个有序数列，直到全部元素有序&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://zouchanglin.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="https://zouchanglin.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>O(n²)的三个排序算法</title>
    <link href="https://zouchanglin.cn/2020/04/07/O(n%C2%B2)%E7%9A%84%E4%B8%89%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://zouchanglin.cn/2020/04/07/O(n%C2%B2)%E7%9A%84%E4%B8%89%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2020-04-07T10:00:00.000Z</published>
    <updated>2020-04-10T01:41:15.470Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;今天复习下最简单的三个排序算法，一个是选择排序，一个是插入排序，一个是冒泡排序，三者时间复杂度都是O(n²)，通过分析来发现三者的优劣，以及对最好的情况和最坏的情况进行分析。 另外，这三中排序算法都是基于比较的排序算法。基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。所以，如果我们在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://zouchanglin.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="https://zouchanglin.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot自动配置原理</title>
    <link href="https://zouchanglin.cn/2020/04/06/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/"/>
    <id>https://zouchanglin.cn/2020/04/06/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/</id>
    <published>2020-04-06T10:00:00.000Z</published>
    <updated>2020-04-25T04:46:07.632Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;我们知道SpringBoot的理念就是约定大于配置，这也使得我们在开发应用程序的过程更加便捷，以前的大量XML配置直接是噩梦呀，现在出现了SpringBoot明显降低了开发成本，而且大量的注解的使用帮我们省略掉了很多代码。本篇文章主要探究的是SpringBoot是如何实现自动配置并且如何加载配置Bean的，其实主要就是探究@EnableAutoConfiguration注解究竟发挥了怎样的作用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web开发" scheme="https://zouchanglin.cn/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaEE" scheme="https://zouchanglin.cn/tags/JavaEE/"/>
    
      <category term="SpringBoot" scheme="https://zouchanglin.cn/tags/SpringBoot/"/>
    
      <category term="SpringCore" scheme="https://zouchanglin.cn/tags/SpringCore/"/>
    
  </entry>
  
  <entry>
    <title>SpringIOC原理与应用</title>
    <link href="https://zouchanglin.cn/2020/04/05/SpringIOC%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <id>https://zouchanglin.cn/2020/04/05/SpringIOC%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/</id>
    <published>2020-04-05T10:00:00.000Z</published>
    <updated>2020-04-14T03:02:16.327Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200405/HbNPDVawlHpU.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;ICO容器的结构如上图所示，首先要让IOC容器去读取Bean的配置信息，并在容器中生成一份相应的Bean定义注册表，根据这张注册表去实例化Bean，装配好Bean之间的依赖关系，为上层提供准备就绪的环境，Spring提供一个配置文件描述Bean还有Bean之间的依赖关系，利用Java语言的反射功能实例化Bean并建立Bean之间的依赖关系。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web开发" scheme="https://zouchanglin.cn/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaEE" scheme="https://zouchanglin.cn/tags/JavaEE/"/>
    
      <category term="SpringCore" scheme="https://zouchanglin.cn/tags/SpringCore/"/>
    
  </entry>
  
  <entry>
    <title>如何理解SpringIOC</title>
    <link href="https://zouchanglin.cn/2020/04/05/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3SpringIOC/"/>
    <id>https://zouchanglin.cn/2020/04/05/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3SpringIOC/</id>
    <published>2020-04-05T06:00:00.000Z</published>
    <updated>2020-04-14T03:02:25.225Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200405/IHCyMIrsdTrx.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;SpringIOC是Spring Core最核心的部分，要了解控制反转(Inversion of Control)，我觉得有必要先了解软件设计的一个重要思想：依赖倒置原则。 &lt;/p&gt;
&lt;p&gt;1、高层模块不应该依赖底层模块，二者都应该依赖抽象&lt;br&gt;2、抽象不应该依赖细节，细节应该依赖抽象。&lt;br&gt;3、依赖倒置的中心思想是面向接口编程。&lt;br&gt;4、依赖倒置原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础搭建的架构要稳定的多。&lt;br&gt;5、使用接口或抽象类的目的是指定好规范，而不涉及任何具体操作，展现细节的任务交给他们的实现类来完成。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web开发" scheme="https://zouchanglin.cn/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaEE" scheme="https://zouchanglin.cn/tags/JavaEE/"/>
    
      <category term="SpringCore" scheme="https://zouchanglin.cn/tags/SpringCore/"/>
    
  </entry>
  
  <entry>
    <title>JUC的四个并发工具类</title>
    <link href="https://zouchanglin.cn/2020/04/05/JUC%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>https://zouchanglin.cn/2020/04/05/JUC%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/</id>
    <published>2020-04-05T04:00:00.000Z</published>
    <updated>2020-04-14T03:05:32.002Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章主要记录了JUC的四个并发工具类，闭锁CountDownlatch、栅栏CyclicBarrier、信号量Semaphore、交换器Exchanger。CountDownlatch通常用于主线程等待其他任务线程执行完毕的场景；CyclicBarrier主要阻塞当前线程，等待其他线程（大家无论谁先跑到A点，必须要等其他线程也到达了A点，大家才能继续）。信号量Semaphore可以用来控制同时访问特定资源的线程数量（比如100个线程只能有10个线程可以获得MySQL连接）。交换器Exchanger很少用，只适用于两个线程在同步点交换数据的场景（如下图）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200404/xTzG4uGsytB7.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="并发编程" scheme="https://zouchanglin.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="异步" scheme="https://zouchanglin.cn/tags/%E5%BC%82%E6%AD%A5/"/>
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
      <category term="JUC" scheme="https://zouchanglin.cn/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>ForkJoin框架与读写锁</title>
    <link href="https://zouchanglin.cn/2020/04/04/ForkJoin%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%BB%E5%86%99%E9%94%81/"/>
    <id>https://zouchanglin.cn/2020/04/04/ForkJoin%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%BB%E5%86%99%E9%94%81/</id>
    <published>2020-04-04T04:00:00.000Z</published>
    <updated>2020-04-14T03:05:45.788Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Fork/Join框架就是在必要的情况下，将一个大任务，进行拆分（fork）成若千个小任务（拆到不可再拆时），再将一个个的小任务运算的结果进行join汇总。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn///20200404/ChkDGz2ekXrP.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;ForkJoin框架采用&lt;code&gt;工作窃取&lt;/code&gt;模式(work-stealing) :当执行新的任务时它可以将其拆分分成更小的任务执行，并将小任务加到线程队列中，然后再从一个随机线程的队列中偷一个并把它放在自己的队列中。&lt;/p&gt;
&lt;p&gt;相对于一般的线程池实现，fork/join框架的优势体现在对其中包含的任务的处理方式上，在一般的线程池中，如果一个线程正在执行的任务由于某些原因无法继续运行，那么该线程会处于等待状态。而在fork/join框架实现中，如果某个子问题由于等待另外一个子问题的完成而无法继续运行。那么处理该子问题的线程会主动寻找其他尚未运行的子问题来执行。这种方式减少了线程的等待时间，提高了性能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="并发编程" scheme="https://zouchanglin.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JavaSE" scheme="https://zouchanglin.cn/tags/JavaSE/"/>
    
      <category term="JUC" scheme="https://zouchanglin.cn/tags/JUC/"/>
    
  </entry>
  
</feed>
