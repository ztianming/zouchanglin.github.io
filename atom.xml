<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tim&#39;s Blog</title>
  
  <subtitle>当你凝望深渊时，深渊也在凝望你</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zouchanglin.cn/"/>
  <updated>2020-02-28T14:38:14.027Z</updated>
  <id>https://zouchanglin.cn/</id>
  
  <author>
    <name>changlin zou</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis的数据类型</title>
    <link href="https://zouchanglin.cn/2020/02/28/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://zouchanglin.cn/2020/02/28/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-02-28T12:01:35.000Z</published>
    <updated>2020-02-28T14:38:14.027Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;今天主要介绍的是Redis的数据类型，顺便说说Redis的ping-pong：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200228/SRyi77FjHYPF.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://zouchanglin.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Redis" scheme="https://zouchanglin.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB秒级快照原理与当前读</title>
    <link href="https://zouchanglin.cn/2020/02/27/InnoDB%E7%A7%92%E7%BA%A7%E5%BF%AB%E7%85%A7%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BD%93%E5%89%8D%E8%AF%BB/"/>
    <id>https://zouchanglin.cn/2020/02/27/InnoDB%E7%A7%92%E7%BA%A7%E5%BF%AB%E7%85%A7%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BD%93%E5%89%8D%E8%AF%BB/</id>
    <published>2020-02-27T12:01:35.000Z</published>
    <updated>2020-02-27T09:33:42.040Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200227/9xbkj74TxjVu.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;在之前为文章&lt;a href=&quot;https://zouchanglin.cn/2020/02/26/分析事务隔离的实现&quot;&gt;《分析事务隔离的实现》&lt;/a&gt;中我们提到：如果是可重复读隔离级别，事务T启动的时候会创建一个视图 read-view，之后事务 T 执行期间，即使有其他事务修改了数据，事务 T 看到的仍然跟在启动时看到的一样。也就是说，一个在可重复读隔离级别下执行的事务，好像与世无争，不受外界影响。但是，我在介绍MySQL锁机制的文章中&lt;a href=&quot;https://zouchanglin.cn/2019/10/25/探究MySQL锁机制&quot;&gt;《探究MySQL锁机制》&lt;/a&gt; 的时候，一个事务要更新一行，如果刚好有另外一个事务拥有这一行的行锁，它会被锁住，进入等待状态。问题是，既然进入了等待状态，那么等到这个事务自己获取到行锁要更新数据的时候，它读到的值又是什么呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://zouchanglin.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://zouchanglin.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>分析事务隔离的实现</title>
    <link href="https://zouchanglin.cn/2020/02/27/%E5%88%86%E6%9E%90%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://zouchanglin.cn/2020/02/27/%E5%88%86%E6%9E%90%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-02-27T00:01:35.000Z</published>
    <updated>2020-02-27T09:41:45.016Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200227/a3pBOiztLcnN.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;关于MySQL的锁机制问题，在之前的博客中有谈到&lt;a href=&quot;https://zouchanglin.cn/2019/10/25/探究MySQL锁机制&quot;&gt;《探究MySQL锁机制》&lt;/a&gt; ，里面对锁的讲解比较详细，现在是在原来的基础上谈谈数据库事务相关的问题。简单来说事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在MySQL中，事务支持是在引擎层实现的。你现在知道，MySQL是一个支持多引擎的系统，但并不是所有的引|擎都支持事务。比如MySQL原生的MyISAM引擎就不支持事务，这也是MyISAM被InnoDB取代的重要原因之一。首先要知道的是数据库事务四大特性：ACID&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://zouchanglin.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://zouchanglin.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>密集索引和稀疏索引</title>
    <link href="https://zouchanglin.cn/2020/02/26/%E5%AF%86%E9%9B%86%E7%B4%A2%E5%BC%95%E5%92%8C%E7%A8%80%E7%96%8F%E7%B4%A2%E5%BC%95/"/>
    <id>https://zouchanglin.cn/2020/02/26/%E5%AF%86%E9%9B%86%E7%B4%A2%E5%BC%95%E5%92%8C%E7%A8%80%E7%96%8F%E7%B4%A2%E5%BC%95/</id>
    <published>2020-02-26T12:01:35.000Z</published>
    <updated>2020-02-27T09:37:13.115Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;密集索引：文件中的每个搜索码值都对应一个索引值，就是叶子节点保存了整行，比如InnoDB&lt;/p&gt;
&lt;p&gt;稀疏索引：文件只为索引码的某些值建立索引项，比如MyISAM&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200226/L4dIVF9GX4Si.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;密集索引的表数据按顺序存储，即索引顺序和表记录物理存储顺序一致，所以一个表只能创建一个密集索引&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://zouchanglin.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="索引" scheme="https://zouchanglin.cn/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="MySQL" scheme="https://zouchanglin.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>BTree与B+Tree</title>
    <link href="https://zouchanglin.cn/2020/02/26/BTree%E4%B8%8EB+Tree/"/>
    <id>https://zouchanglin.cn/2020/02/26/BTree%E4%B8%8EB+Tree/</id>
    <published>2020-02-26T11:01:35.000Z</published>
    <updated>2020-02-27T09:37:19.929Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;其实在之前的文章说说到过MySQL索引，只不过没细说，&lt;a href=&quot;https://zouchanglin.cn/2019/09/12/JOIN查询与索引简介/#5、MySQL索引结构&quot;&gt;《JOIN查询与索引简介》&lt;/a&gt; ，现在来看看回顾一下索引相关的数据结构，首先看看索引的定义： 索引(Index)是帮助MySQL高效获取数据的数据结构。 我不会索引就是类似于字典这样的话泛泛而谈，而是如何真正去理解索引。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://zouchanglin.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="索引" scheme="https://zouchanglin.cn/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="MySQL" scheme="https://zouchanglin.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS协议实现原理</title>
    <link href="https://zouchanglin.cn/2020/02/25/HTTPS%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://zouchanglin.cn/2020/02/25/HTTPS%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2020-02-25T11:01:35.000Z</published>
    <updated>2020-02-27T09:37:33.784Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200225/meVCCACO399R.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;HTTP协议的信息传输完全以明文方式，不做任何加密，相当于是在网络上”裸奔”。意思就是如果我们以HTTP来传输数据的话由于是明文数据，则很容易发生不安全事故，比如我登陆一个网站，那么如果是HTTP明文传输肯定就会直接把用户名和密码放在明文中，这样是非常不安全的，处在同一个局域网下的小伙伴直接抓包就可以获取你的用户名和密码，那么应该怎么办呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://zouchanglin.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://zouchanglin.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="网络安全" scheme="https://zouchanglin.cn/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
      <category term="非对称加密" scheme="https://zouchanglin.cn/tags/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>TCP的高性能机制</title>
    <link href="https://zouchanglin.cn/2020/02/25/TCP%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%9C%BA%E5%88%B6/"/>
    <id>https://zouchanglin.cn/2020/02/25/TCP%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%9C%BA%E5%88%B6/</id>
    <published>2020-02-25T04:01:35.000Z</published>
    <updated>2020-02-27T09:37:48.056Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200225/WFp4qQSRpvoo.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;之前介绍了TCP的报文格式（&lt;a href=&quot;https://zouchanglin.cn/2019/11/21/TCP协议基本特性&quot;&gt;《TCP协议基本特性》&lt;/a&gt;），TCP的连接管理，学习了TCP如何建立连接，释放连接以及一些网络安装方面的问题，现在还剩下TCP的几个关键机制，主要是TPC的延迟应答和捎带应答、超时重传、快重传和快恢复、滑动窗口机制、拥塞避免算法；然后最后还记录了TCP的粘包问题和解决方案！&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://zouchanglin.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://zouchanglin.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>谈谈HTTP协议</title>
    <link href="https://zouchanglin.cn/2020/02/25/%E8%B0%88%E8%B0%88HTTP%E5%8D%8F%E8%AE%AE/"/>
    <id>https://zouchanglin.cn/2020/02/25/%E8%B0%88%E8%B0%88HTTP%E5%8D%8F%E8%AE%AE/</id>
    <published>2020-02-25T04:01:35.000Z</published>
    <updated>2020-02-27T09:37:41.548Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;HTTP的全称 HyperText Transfer Protocol，即超文本传输协议，程序员自己发明的协议之一，基于TCP的应用层协议。 HTTP协议是基于请求-响应的模式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200225/k8pW0raF9ync.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;HTTP是一种无状态协议，HTTP协议自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个级别，协议对于发送过的请求或响应都不做持久化处理。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200225/GqrhjlASQXoQ.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://zouchanglin.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://zouchanglin.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>构造实现简单容器</title>
    <link href="https://zouchanglin.cn/2020/02/24/%E6%9E%84%E9%80%A0%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E5%AE%B9%E5%99%A8/"/>
    <id>https://zouchanglin.cn/2020/02/24/%E6%9E%84%E9%80%A0%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E5%AE%B9%E5%99%A8/</id>
    <published>2020-02-24T14:38:52.000Z</published>
    <updated>2020-02-27T09:38:13.923Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;现在即将开始真正踏上构造自己的容器的道路。我们会基于当前的操作系统创建一个与宿主机隔离的容器环境，下面就开始吧。在开始之前我们需要先对Linux的proc文件系统做一个介绍：&lt;/p&gt;
&lt;p&gt;如果你对这些基本知识已经很熟悉了，请直接略过。Linux下的/proc文件系统是由内核提供的，它其实不是一个真正的文件系统，只包含了系统运行时的信息（比如系统内存、mount设备信息、一些硬件配置等），它只存在于内存中，而不占用外存空间。它以文件系统的形式，为访问内核数据的操作提供接口。实际上，很多系统工具都是简单地去读取这个文件系统的某个文件内容，比如lsmod，其实就是cat /proc/modules。当遍历这个目录的时候，会发现很多数字，这些都是为每个进程创建的空间，数字就是它们的PID。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200224/sVzVSYCvKI6y.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="虚拟化技术" scheme="https://zouchanglin.cn/categories/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="https://zouchanglin.cn/tags/Linux/"/>
    
      <category term="Docker" scheme="https://zouchanglin.cn/tags/Docker/"/>
    
      <category term="Golang" scheme="https://zouchanglin.cn/tags/Golang/"/>
    
      <category term="文件系统" scheme="https://zouchanglin.cn/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>动手实现AUFS文件系统</title>
    <link href="https://zouchanglin.cn/2020/02/23/%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0AUFS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>https://zouchanglin.cn/2020/02/23/%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0AUFS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-02-23T03:37:40.000Z</published>
    <updated>2020-02-27T09:38:27.994Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200223/8sHdcObI1bOG.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;在之前的文章中我们探究了Docker是如何使用AUFS文件系统的，现在我们开始动手实践一下AUFS，用简单的命令来创建一个AUFS文件系统，感受下如何使用AUFS和COW实现文件管理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="虚拟化技术" scheme="https://zouchanglin.cn/categories/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="https://zouchanglin.cn/tags/Linux/"/>
    
      <category term="Docker" scheme="https://zouchanglin.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Union File System在Docker中的应用</title>
    <link href="https://zouchanglin.cn/2020/02/22/Union%20File%20System%E5%9C%A8Docker%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>https://zouchanglin.cn/2020/02/22/Union%20File%20System%E5%9C%A8Docker%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</id>
    <published>2020-02-22T07:15:41.000Z</published>
    <updated>2020-02-27T09:38:35.225Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Union-File-System&quot;&gt;&lt;a href=&quot;#Union-File-System&quot; class=&quot;headerlink&quot; title=&quot;Union File System&quot;&gt;&lt;/a&gt;Union File System&lt;/h2&gt;&lt;p&gt;Union File System，简称UnionFS，关于联合文件系统我之前的一篇博客里也写过的&lt;a href=&quot;https://zouchanglin.cn/2019/08/03/Docker镜像与数据容器卷&quot;&gt;《Docker镜像与数据容器卷》&lt;/a&gt;，是一种为Linux、FreeBSD 和NetBSD操作系统设计的，把其他文件系统联合到一个联合挂载点的文件系统服务。它使用branch把不同文件系统的文件和目录“透明地”覆盖，形成一个单一一致的文件系统。这些branch或者是read-only的，或者是read-write的，所以当对这个虚拟后的联合文件系统进行写操作的时候，系统是真正写到了一个新的文件中。看起来这个虚拟后的联合文件系统是可以对任何文件进行操作的，但是其实它并没有改变原来的文件,这是因为unionfs用到了一个重要的资源管理技术，叫写时拷贝。&lt;/p&gt;
    
    </summary>
    
    
      <category term="虚拟化技术" scheme="https://zouchanglin.cn/categories/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="https://zouchanglin.cn/tags/Linux/"/>
    
      <category term="Docker" scheme="https://zouchanglin.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Cgroups在Docker中的应用</title>
    <link href="https://zouchanglin.cn/2020/02/22/Cgroups%E5%9C%A8Docker%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>https://zouchanglin.cn/2020/02/22/Cgroups%E5%9C%A8Docker%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</id>
    <published>2020-02-22T04:20:19.000Z</published>
    <updated>2020-02-27T09:38:42.118Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;之前几篇文章讲述了Linux的Cgroups技术，&lt;a href=&quot;https://zouchanglin.cn/2020/02/20/Linux-Cgroups的资源控制/&quot;&gt;《Linux-Cgroups的资源控制》&lt;/a&gt;，主要是通过Cgroups实现了对进程的资源限制，那么在Docker中是如何运用Cgroups的呢？我们知道Docker是通过Cgroups去做的容器的资源限制和监控，我们下面就以一个实际的容器实例来看下Docker是如何配置Cgroups的：&lt;code&gt;docker run -m 设置内存限制&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200222/U7v1jf2JBKla.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以看到Docker通过为每个容器创建Cgroup并通过Cgroup去配置的资源限制和资源监控。&lt;/strong&gt; &lt;/p&gt;
    
    </summary>
    
    
      <category term="虚拟化技术" scheme="https://zouchanglin.cn/categories/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="https://zouchanglin.cn/tags/Linux/"/>
    
      <category term="Docker" scheme="https://zouchanglin.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Apache Freemarker的一个小坑</title>
    <link href="https://zouchanglin.cn/2020/02/21/Apache-Freemarker%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9D%91/"/>
    <id>https://zouchanglin.cn/2020/02/21/Apache-Freemarker%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9D%91/</id>
    <published>2020-02-21T03:38:53.000Z</published>
    <updated>2020-02-27T09:38:50.135Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn/FjkyX6iIHmYl6IFqrwnlZUnLBFXd&quot; alt=&quot;xxx.png&quot;&gt;&lt;br&gt;前段时间用到了Apache Freemarker来做前端页面，发现一个问题，就是JavaBean的Long类型和Integer类型向模板中注入的时候，只要是注入input类型，那么大&lt;br&gt;于999的数字则不会被显示，这个问题我也问了Apache官方的论坛：&lt;a href=&quot;https://issues.apache.org/jira/browse/FREEMARKER-132&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://issues.apache.org/jira/browse/FREEMARKER-132&lt;/a&gt; ,果然是官方站点呀，反馈还是很快的，系统还自动发了邮件！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web开发" scheme="https://zouchanglin.cn/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaWeb" scheme="https://zouchanglin.cn/tags/JavaWeb/"/>
    
      <category term="模板引擎" scheme="https://zouchanglin.cn/tags/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"/>
    
      <category term="前端" scheme="https://zouchanglin.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Linux Cgroups的资源控制</title>
    <link href="https://zouchanglin.cn/2020/02/20/Linux-Cgroups%E7%9A%84%E8%B5%84%E6%BA%90%E6%8E%A7%E5%88%B6/"/>
    <id>https://zouchanglin.cn/2020/02/20/Linux-Cgroups%E7%9A%84%E8%B5%84%E6%BA%90%E6%8E%A7%E5%88%B6/</id>
    <published>2020-02-20T12:03:27.000Z</published>
    <updated>2020-02-27T09:38:57.162Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;今天主要是说说Linux的Cgroup技术，之前介绍的是构建Linux容器的namespace技术，它能够很好的帮助进程隔离出自己单独的空间，但Docker又是怎么限制每个空间的大小，保证他们不会互相争抢呢？这就要用到Linux的Cgroups技术。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200221/EHaOfXGVfWwE.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;Linux Cgroups(Control Groups) 提供了对一组进程及将来的子进程的资源的限制 ，控制和统计的能力，这些资源包括CPU，内存，存储，网络等。通过Cgroups，可以方便的限制某个进程的资源占用，并且可以实时的监控进程的监控和统计信息。&lt;/p&gt;
    
    </summary>
    
    
      <category term="虚拟化技术" scheme="https://zouchanglin.cn/categories/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="https://zouchanglin.cn/tags/Linux/"/>
    
      <category term="Docker" scheme="https://zouchanglin.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>通过Namespace实现隔离</title>
    <link href="https://zouchanglin.cn/2020/02/19/%E9%80%9A%E8%BF%87Namespace%E5%AE%9E%E7%8E%B0%E9%9A%94%E7%A6%BB/"/>
    <id>https://zouchanglin.cn/2020/02/19/%E9%80%9A%E8%BF%87Namespace%E5%AE%9E%E7%8E%B0%E9%9A%94%E7%A6%BB/</id>
    <published>2020-02-19T07:02:22.000Z</published>
    <updated>2020-02-20T06:54:10.387Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200219/96tchOUQRfiQ.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;在上次的文章&lt;a href=&quot;[https://zouchanglin.cn/2020/02/18/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%9F%BA%E7%9F%B3%E2%80%94%E2%80%94Namespace/](https://zouchanglin.cn/2020/02/18/虚拟化的基石——Namespace/)&quot;&gt;《虚拟化的基石——Namespace》&lt;/a&gt; 中主要讲述了Namespace的作用，却没有详细的拿代码举证，上次仅仅证明了UTS Namespace，剩下五个命名空间全在这篇文章了，主要是IPC Namespace、PID Namespace、Mount Namespace、User Namespace、Network Namespace的概念的理解以及使用代码证明！&lt;/p&gt;
    
    </summary>
    
    
      <category term="虚拟化技术" scheme="https://zouchanglin.cn/categories/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="https://zouchanglin.cn/tags/Linux/"/>
    
      <category term="Docker" scheme="https://zouchanglin.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>虚拟化的基石——Namespace</title>
    <link href="https://zouchanglin.cn/2020/02/18/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%9F%BA%E7%9F%B3%E2%80%94%E2%80%94Namespace/"/>
    <id>https://zouchanglin.cn/2020/02/18/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%9F%BA%E7%9F%B3%E2%80%94%E2%80%94Namespace/</id>
    <published>2020-02-18T14:44:21.000Z</published>
    <updated>2020-02-20T06:54:14.123Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;每每被人问到：“Docker技术到底是怎么实现的呢？”我只能粗粗浅浅地说：“Docker是使用Linux Kernel的Namespace 和 Cgroups实现的一种容器技术。”那么，什么是Namespace，什么是Cgroups，Docker是怎么使用它们的，容器到底是怎么一步步被创建出来的？问到这些，我就会支支吾吾地不知所以。由此可见，了解容器技术的底层技术，然后明白它们是如何工作的，尤为重要，这些才是整个容器技术的基石，掌握了这些基石才能更加容易地向上攀登。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那今天就先看看Namespace吧！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200218/07pgJ5CxHbna.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="虚拟化技术" scheme="https://zouchanglin.cn/categories/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="https://zouchanglin.cn/tags/Linux/"/>
    
      <category term="Docker" scheme="https://zouchanglin.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>构建可复用模块</title>
    <link href="https://zouchanglin.cn/2020/02/18/%E6%9E%84%E5%BB%BA%E5%8F%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E6%A8%A1%E5%9D%97/"/>
    <id>https://zouchanglin.cn/2020/02/18/%E6%9E%84%E5%BB%BA%E5%8F%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E6%A8%A1%E5%9D%97/</id>
    <published>2020-02-18T02:27:22.000Z</published>
    <updated>2020-02-20T06:53:57.117Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Golang的工程管理一直是初学者所不能很好的理解的事物，本篇主要讲述了在Golang中如何进行工程管理，如何构建可复用模块，从GitHub获取Go的包是如何操作的，以及Golang的包管理工具的基本使用，这样再进行项目开发的时候就可以模块化的管理自己的工程，首先还得从Package说起！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200218/9Uui7Swk4Vcp.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="工程构建" scheme="https://zouchanglin.cn/categories/%E5%B7%A5%E7%A8%8B%E6%9E%84%E5%BB%BA/"/>
    
    
      <category term="Golang" scheme="https://zouchanglin.cn/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>在Golang中处理异常</title>
    <link href="https://zouchanglin.cn/2020/02/17/%E5%9C%A8Golang%E4%B8%AD%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8/"/>
    <id>https://zouchanglin.cn/2020/02/17/%E5%9C%A8Golang%E4%B8%AD%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8/</id>
    <published>2020-02-17T12:04:22.000Z</published>
    <updated>2020-02-20T06:54:25.469Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;通常我们需要编写好的错误处理方式，在了避免某些程序员滥用异常，于是Go这里直接把异常这一块给砍掉了，最终还是通过返回值来判断程序的异常情况，毕竟Go可是支持多返回值的语言，比如atoi、itoa等函数，就不能忽略它的第二个返回值，因为第二个返回值代表了转换是否成功！不过Golang还是提供了一些错误处理机制的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200217/IvGCHwjRpvVi.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="https://zouchanglin.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Golang" scheme="https://zouchanglin.cn/tags/Golang/"/>
    
      <category term="异常处理" scheme="https://zouchanglin.cn/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>实践Go的面向对象</title>
    <link href="https://zouchanglin.cn/2020/02/17/%E5%AE%9E%E8%B7%B5Go%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>https://zouchanglin.cn/2020/02/17/%E5%AE%9E%E8%B7%B5Go%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</id>
    <published>2020-02-17T09:22:21.000Z</published>
    <updated>2020-02-20T06:54:06.178Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Go是一种面向对象的语言吗？ &lt;/p&gt;
&lt;p&gt;关于Go是一种面向对象的语言吗这种问题，官方的解释是难说，说不准，这回答就有意思了！在我看来尽管Go具有类型和方法，并允许使用面向对象的编程风格，但没有类型层次结构。 Go的接口完全提供了一种不同的方法，可以将类型嵌入其他类型，达到继承的效果，其实又完全不同于继承，因为Go其中一个特点是可以为任何类型的数据定义方法，所以再讨论Go是不是面向对象的语言的时候还是可以先体验体验Go的Functional Programming&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200217/KzljGvryaBkw.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="https://zouchanglin.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Golang" scheme="https://zouchanglin.cn/tags/Golang/"/>
    
      <category term="面向对象" scheme="https://zouchanglin.cn/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Golang值得注意的点</title>
    <link href="https://zouchanglin.cn/2020/02/16/Golang%E5%80%BC%E5%BE%97%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9/"/>
    <id>https://zouchanglin.cn/2020/02/16/Golang%E5%80%BC%E5%BE%97%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9/</id>
    <published>2020-02-16T08:52:02.000Z</published>
    <updated>2020-02-20T06:57:11.374Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;记录了一下最近学习golang语言遗忘的和模糊的知识点，主要涵盖主函数退出返回值、如何编写测试程序、如何定义常量、golang的类型转换、golang中的预定义值、指针与其他语言的差异（主要是C语言），以及运算符等等！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.zouchanglin.cn///20200216/SHPRYlCdVQO1.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="https://zouchanglin.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Golang" scheme="https://zouchanglin.cn/tags/Golang/"/>
    
  </entry>
  
</feed>
